{"meta":{"title":"Bomblebee","subtitle":"","description":"","author":"Huang Feng","url":"http://dangkei.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-01T06:15:40.117Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"http://dangkei.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-01T06:15:40.121Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"http://dangkei.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-01T08:52:42.262Z","updated":"2021-07-01T08:52:42.262Z","comments":false,"path":"about/index.html","permalink":"http://dangkei.github.io/about/index.html","excerpt":"","text":"2021-07-01 建党100周年纪念日看到一个好的主题pure，感觉非常不错就换了，非常感谢这个主题的作者，虽然更新后很多内容都没有了，不过还好有备份。 有时间慢慢恢复吧。自己已经是一个大龄程序员了， 走过很长一段人生路， 对生命，生活，亲情，爱情，家庭都有了一些新的认知。 希望今后的道路上让编程重新成为自己的爱好而不止是谋生的手段，重拾自己对技术的兴趣。 也希望自己身边的人都健康，快乐。"},{"title":"友情链接","date":"2021-07-01T06:15:40.124Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"http://dangkei.github.io/links/index.html","excerpt":"","text":""},{"title":"项目库","date":"2021-07-01T07:53:18.384Z","updated":"2021-07-01T07:53:18.384Z","comments":false,"path":"repository/index.html","permalink":"http://dangkei.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-05T07:35:42.586Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://dangkei.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-01T06:15:40.204Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"http://dangkei.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-07-05T08:32:38.116Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"http://dangkei.github.io/404.html","excerpt":"","text":""}],"posts":[{"title":"how-to-use-docker-2","slug":"how-to-use-docker-2","date":"2021-07-13T06:33:59.000Z","updated":"2021-07-13T08:41:57.547Z","comments":true,"path":"2021/07/13/how-to-use-docker-2/","link":"","permalink":"http://dangkei.github.io/2021/07/13/how-to-use-docker-2/","excerpt":"","text":"挂载文件及目录 在个人开发电脑上装了docker以后就想把自己平时的本地开发环境全部转成docker管理方式首先想转换的就是redis数据库,我们平时用的redis设置密码 外加持久化存储。默认的镜像肯定不能满足开发环境需求。查了一些资料过程不说了最后整理下面的命令。 1docker run -p 6379:6379 --name redis6379 -v D:\\Database\\redis3.0.5\\redis_6379.conf:/etc/redis/redis.conf -v D:\\Database\\data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes 拆解说明一下 6379：6379 第一个6379 是本地发布映射端口 第二个6379是镜像中默认端口 --name redis6379 给容器起一个名字方便以后使用 -v D:\\Database\\redis3.0.5\\redis_6379.conf:/etc/redis/redis.conf -v D:\\Database\\data:/data 参数-v的作用是挂载本地系统文件或文件夹,这里使用了两次， 第一个-v挂载本地redis_6379.conf到镜像容器中命名为redis.conf 第二个-v挂载本地的D:\\Database\\data目录为容器中的/data目录 -d redis -d redis 是后台使用redis镜像启动 redis-server /etc/redis/redis.conf启动后使用挂载的配置文件来启动redis --appendonly yesredis配置选项持久化存储打开 这样命令执行完之后我就可以使用docker管理开发环境的redis服务器启动。而不是需要在本地命令行或者通过配置windows服务的方式启动redis。而各种设置和数据的存储和在本地安装程序一样。 可以想象一下，如果将来我们更换电脑或者开发环境。 只需保存好配置文件，和数据存储文件。就可以快速部署或者一个和之前一样的开发环境。 通过-v这个参数的挂载功能将应用参数数据完全与数据库或者中间件分离，方便快速管理部署。 1docker pull mysql:5.7.25","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how-to-use-docker","slug":"how-to-use-hub-docker","date":"2021-07-12T09:31:31.000Z","updated":"2021-07-13T08:53:44.608Z","comments":true,"path":"2021/07/12/how-to-use-hub-docker/","link":"","permalink":"http://dangkei.github.io/2021/07/12/how-to-use-hub-docker/","excerpt":"","text":"1. download for windows https://hub.docker.com/ 安装步骤省略 按提示一步步安装即可 2. find a image 我们可以在网站上找一些官方的镜像[Official Images]例如 我搜索一下nginx 在结果中 我选择类型为Official Images的直接拿来可以使用 也可以在命令行执行 1docker search nginx 点击进入后页面右侧会有提示该如何在本地下载该镜像 直接拷贝命令后到本地命令行执行 123456789101112E:\\code\\&gt;docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxb4d181a07f80: Already exists66b1c490df3f: Pull completed0f91ae9b44c: Pull completebaf987068537: Pull complete6bbc76cbebeb: Pull complete32b766478bc2: Pull completeDigest: sha256:353c20f74d9b6aee359f30e8e4f69c3d7eaea2f610681c4a95849a2fd7c497f9Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest 然后打开 docker-desktop 可以看到本地已经有nginx的镜像可以直接使用了。 3. use the image点击run就直接在本地运行一个redis的docker容器。或者使用命令行 1docker run --name mynginx -d nginx:latest docker run 参数很多。 有机会需要的时候可以慢慢研究。这里就不做详细介绍了。 4. 一些简单的docker命令行命令 查看本地有哪些镜像 1docker images 查看本地运行的docker 容器 1docker ps 进入容器内命令行 1docker exec -i -t 容器ID /bin/bash 修改容器配置常用命令 12apt-get updateapt-get install -y vim 一般官方容器装的软件很少，我们要修改一些基本配置至少要安装下vi 复制当前系统中文件到docker容器中 1docker cp D:\\Database\\redis3.0.5\\redis_6379.conf db0794db0d16:/etc/redis/redis.conf 后来发现中间件配置文件 简单介绍这些菜鸟教程里比较全有需要可以去那边查，祝大家学习愉快！https://www.runoob.com/docker/docker-command-manual.html","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"Java 8特色Lambda 表达式","slug":"lambda-expressions","date":"2021-07-09T02:58:38.000Z","updated":"2021-07-09T02:47:39.238Z","comments":true,"path":"2021/07/09/lambda-expressions/","link":"","permalink":"http://dangkei.github.io/2021/07/09/lambda-expressions/","excerpt":"","text":"Java 8 – Lambda 表达式 Lambda 表达式是Java 8 的一个非常新的和令人兴奋的特性。Lambda 样式表达式对于我们中许多从事过像 Scala 这样的高级语言工作的人来说并不陌生。 在本 Java 教程中，我们将了解 lambda 表达式及其相关的各种概念。 什么是 Lambda 表达式？ Lambda 表达式语法 Java 8 Lambda 表达式的特点 Java 8 功能接口 Java 8 Lambda 表达式示例 让我们按部就班，一步一步来。 1. 什么是 Lambda 表达式？ 在一般编程语言中，Lambda 表达式（或函数）是匿名函数，即没有名称和任何标识符的函数。 Lambda 表达式是作为常量值给出的无名函数，并准确地写在需要它的地方，通常作为其他函数的参数。 Lambda 表达式最重要的特性是它们在其外观的上下文中执行。因此，类似的 lambda 表达式可以在其他一些上下文中以不同的方式执行（即逻辑将相同但结果将根据传递给函数的不同参数而不同）。 上面的定义充满了关键字，只有当你对什么是 lambda 表达式有一点了解时才能理解。因此，一旦您在下一节中对 lambda 表达式有了更好的理解，我建议您重新阅读上一段。 与面向对象编程(OOP) 相比，Lambda 表达式为函数式编程提供了许多好处。大多数 OOP 语言围绕类和对象发展，这些语言只将类视为它们的一等公民。另一个重要的实体，即职能部门，处于次要地位。 在 Java 中尤其如此，其中函数不能存在于对象之外。函数本身在 Java 中没有任何意义，除非它与某个对象或实例相关。 但是在函数式编程中，我们可以定义函数，给它们提供引用变量，并将它们作为方法参数传递等等。 JavaScript 是函数式编程的一个很好的例子，我们可以将回调方法传递给Ajax调用等等。这是一个非常有用的特性，从一开始就缺乏Java。现在有了 Java 8，我们还可以在 lambda 表达式的帮助下使用函数式编程概念。 2. Lambda 表达式语法典型的 lambda 表达式语法如下所示： 1(parameters) -&gt; expression 例如，给定的 lambda 表达式接受两个参数并返回它们的相加。 根据xand的类型y，表达式的使用方式会有所不同。如果参数与Integer表达式匹配，则将两个数字相加。如果参数类型String为表达式，则将连接两个字符串。 1(x, y) -&gt; x + y 3. Java 8 Lambda 表达式的特点一个 lambda 表达式可以有零个、一个或多个参数。参数的类型可以显式声明，也可以从上下文中推断出来。多个参数用强制括号括起来并用逗号分隔。空括号用于表示一组空参数。 1() -&gt; expression (param1, param2, param3) -&gt; expression 当有单个参数时，如果推断其类型，则不强制使用括号。例如 a -&gt; 返回 a*a。lambda 表达式的主体可以包含零个、一个或多个语句。如果 lambda 表达式的主体有单个语句，则大括号不是必需的，并且匿名函数的返回类型与主体表达式的返回类型相同。当正文中有多个语句时，必须将这些语句括在大括号中。(parameters) -&gt; &#123; statements; &#125;因此，我们简要概述了什么是 lambda 表达式。在深入研究 lambda 表达式和 Java 编程之间的关系之前，我们还必须了解函数式接口。这太重要了。 4. Java 8 功能接口单一抽象方法接口（SAM Interfaces）并不是一个新概念。这意味着只有一种方法的接口。在 Java 中，我们已经有很多此类 SAM 接口的示例。 从 Java 8 开始，SAM 接口也将被称为功能接口。Java 8通过使用新的注释（即@FunctionalInterface ）标记这些接口来强制执行单一职责的规则。 例如，Runnable 接口的新定义是这样的： 1234@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 如果我们尝试在任何函数式接口中添加新方法，编译器将不允许您这样做，并且会抛出编译时错误。 我们知道 Lambda 表达式是没有名称的匿名函数，它们（主要）作为参数传递给其他函数。好吧，在 Java 中，方法参数总是有一个类型，并且会查找类型信息以确定在方法重载甚至简单方法调用的情况下需要调用哪个方法。 因此，基本上每个 lambda 表达式也必须可以转换为某种“类型”才能被接受为方法参数。好吧，转换 lambda 表达式的类型始终是函数式接口类型。 函数式接口类型的两个很好的例子是Consumer和BiConsumer接口。 让我们通过一个例子来理解它。如果我们必须编写一个线程来在控制台中打印“hello word!”，那么最简单的代码将是： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;hello word!&quot;); &#125;&#125;).start(); 如果我们为此任务使用 lambda 表达式，则代码将是： 123new Thread(() -&gt; &#123; System.out.println(&quot;hello word! First!&quot;); &#125;).run(); 这Runnable是一个具有单一方法的功能接口run()。因此，当我们将 lambda 表达式传递给Thread类的构造函数时，编译器会尝试将表达式转换为等效Runnable代码，如第一个代码示例所示。 如果编译器成功，则一切正常。如果编译器无法将表达式转换为等效的实现代码，它就会报错。在这里，在上面的示例中，lambda 表达式被转换为 type Runnable。 lambda 表达式是函数式接口的一个实例，但 lambda 表达式本身不包含有关它正在实现的函数式接口的信息。该信息是从使用表达式的上下文中推导出来的。 5. Java 8 Lambda 表达式示例 我们列出了一些代码示例，您可以阅读并分析如何在我们的日常编程中使用 lambda 表达式。 示例 1：使用 lambda 表达式迭代 List 并对列表元素执行某些操作 在给定的示例中，我们迭代列表并打印标准输出中的所有列表元素。我们可以执行任何所需的操作来代替打印它们。 1234567List&lt;String&gt; pointList = new ArrayList(); pointList.add(&quot;1&quot;);pointList.add(&quot;2&quot;); pointList.forEach(p -&gt; &#123; System.out.println(p); &#125; ); 示例 2：在 Java 中使用 lambda 表达式创建和启动线程在给定的示例中，我们将Runnable接口的实例传递给Thread构造函数。 123new Thread( () -&gt; System.out.println(&quot;My Runnable&quot;); ).start(); 示例 3：使用 lambda 表达式向 GUI 组件添加事件侦听器JButton button = new JButton(&quot;Submit&quot;); button.addActionListener((e) -&gt; &#123; System.out.println(&quot;Click event triggered !!&quot;); &#125;); 以上是 Java 8 中非常基本的 lambda 表达式示例。","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://dangkei.github.io/tags/lambda/"}]},{"title":"nodejs里写一个自定义的redis客户端","slug":"nodejs-redisclient","date":"2021-07-08T07:23:53.000Z","updated":"2021-07-12T06:41:04.287Z","comments":true,"path":"2021/07/08/nodejs-redisclient/","link":"","permalink":"http://dangkei.github.io/2021/07/08/nodejs-redisclient/","excerpt":"","text":"什么是Node.js? Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。 Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 官网上对其特点描述为： 它是一个Javascript运行环境 依赖于Chrome V8引擎进行代码解释 事件驱动 非阻塞I/O 轻量、可伸缩，适于实时数据交互应用 单进程，单线程 Node.js中模块化开发规范Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到。模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块。 自己写一个操作redis的client 模块。 首先我们要在nodejs中使用redis必须下载redis模块，在你的项目文件夹下执行下面命令1npm install redis 按习惯，我们先在项目文件夹下建一个文件夹modules再在这个文件夹下建一个文件夹redis我希望把redis链接的相关信息写在一个配置文件而不是程序内，所以我首先创建一个redis的配置文件文件名为config.jsonconfig.json12345678&#123; &quot;redis&quot;:&#123; &quot;port&quot;:&quot;6379&quot;, &quot;host&quot;:&quot;localhost&quot;, &quot;password&quot;:&quot;password&quot;, &quot;detect_buffers&quot;: &quot;true&quot; &#125;&#125; 开始写redisClient.js,首先把redis插件和自定义的配置文件声明进来 12const redis = require(&#x27;redis&#x27;)const redisOptions = require(&#x27;./config&#x27;).redis 然后设置redis配置信息，出了连接方式还有缓存设置以及重连机制 1234567891011121314151617181920212223242526const options = &#123; host: redisOptions.host, port: redisOptions.port, password: redisOptions.pass, detect_buffers: redisOptions.detect_buffers, // 传入buffer 返回也是buffer 否则会转换成String retry_strategy: function (options) &#123; // 重连机制 if (options.error &amp;&amp; options.error.code === &quot;ECONNREFUSED&quot;) &#123; // End reconnecting on a specific error and flush all commands with // a individual error return new Error(&quot;The server refused the connection&quot;); &#125; if (options.total_retry_time &gt; 1000 * 60 * 60) &#123; // End reconnecting after a specific timeout and flush all commands // with a individual error return new Error(&quot;Retry time exhausted&quot;); &#125; if (options.attempt &gt; 10) &#123; // End reconnecting with built in error return undefined; &#125; // reconnect after return Math.min(options.attempt * 100, 3000); &#125;&#125;","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://dangkei.github.io/tags/redis/"}]},{"title":"Java大括号初始化对象","slug":"Java-double-brace-initialization","date":"2021-07-06T10:30:00.000Z","updated":"2021-07-08T01:19:12.522Z","comments":true,"path":"2021/07/06/Java-double-brace-initialization/","link":"","permalink":"http://dangkei.github.io/2021/07/06/Java-double-brace-initialization/","excerpt":"","text":"Java Double Brace Initialization 1. 创建和初始化不带双大括号的对象您不觉得Java应该为集合（List、Map、Set等）提供更方便的语法吗。我之所以这么说，是因为每次如果我们必须在代码中使用集合，那么我们就必须执行以下操作- 为临时集合声明变量 创建一个新的空集合，并在变量中存储对它的引用 把东西收藏起来 将集合传递给方法 例如：WithoutDoubleBrace.java 123456789101112131415161718192021import java.util.HashSet;import java.util.Set; public class WithoutDoubleBrace &#123; public static void main(String[] args) &#123; Set&lt;String&gt; params = new HashSet&lt;String&gt;(); params.add(&quot;param one&quot;); params.add(&quot;param two&quot;); params.add(&quot;param three&quot;); params.add(&quot;param four&quot;); // ... and so on; Now pass above collection as parameter to method or // some other ways useParamsInSomeMethod(params); &#125; private static void useParamsInSomeMethod(Set&lt;String&gt; params) &#123; // TODO Auto-generated method stub &#125;&#125; 这些都是我们在实时编码实践中遵循的正常步骤。 2. 在“单步”中创建和初始化对象的双大括号初始化让我们看看另一种简单的方法。这就是所谓的双大括号初始化。使用双大括号功能的语法如下： DoubleBrace.java 12345678910111213141516171819202122232425import java.util.HashSet;import java.util.Set; public class DoubleBrace &#123; public static void main(String[] args) &#123; Set&lt;String&gt; params = new HashSet&lt;String&gt;() &#123; &#123; add(&quot;param one&quot;); add(&quot;param two&quot;); add(&quot;param three&quot;); add(&quot;param four&quot;); &#125; &#125;; // ... and so on; Now pass above collection as parameter to method or // some other ways useParamsInSomeMethod(params); &#125; private static void useParamsInSomeMethod(Set&lt;String&gt; params) &#123; // TODO Auto-generated method stub &#125;&#125; 2.1. 内联双大括号初始化或者更简单一些： 12345678910111213141516171819import java.util.HashSet; public class DoubleBrace &#123; public static void main(String[] args) &#123; useParamsInSomeMethod(new HashSet&lt;String&gt;() &#123; &#123; add(&quot;param one&quot;); add(&quot;param two&quot;); add(&quot;param three&quot;); add(&quot;param four&quot;); &#125; &#125;); &#125; private static void useParamsInSomeMethod(HashSet&lt;String&gt; params) &#123; //perform some operation &#125;&#125; 3. 双大括号初始化如何工作？让我们了解这是如何工作的。 第一个大括号创建一个新的匿名内部类。这些内部类能够访问其父类的行为。所以，在我们的例子中，我们实际上是在创建HashSet类的子类，所以这个内部类能够使用add（）方法。 第二组大括号只不过是初始化实例。如果您提醒核心java概念，那么您可以很容易地将实例初始值设定项块与静态初始值设定项相关联，因为类似于大括号的结构。唯一的区别是，静态初始值设定项是用static关键字添加的，并且只运行一次；不管您创建了多少个对象。 4. 总结 因为用双括号初始化的类基本上是内部类。所以我们可以为所有其他类创建它们，直到它们不是最终的。 如果没有显式修改equals（）方法以使用这些类，则不应使用此类类，因为equals（）方法通常也会检查类的相等性。 您应该始终记住，初始值设定项是在构造函数之前运行的（而不是在超类构造函数之前）。 您创建的匿名类的实例包含对封闭对象的合成引用。如果序列化集合，还将序列化外部类中的所有内容。 5. Java 9 工厂方法Java 9带来了很多工厂方法，可以用来创建和初始化单个语句中的Java集合。如果您使用Java 9或更高版本，它可以是一种替代方法，也是首选方法。它消除了双支撑初始化的必要性。 12345678List&lt;String&gt; names = List.of(&quot;lokesh&quot;, &quot;rohit&quot;, &quot;alex&quot;); Set&lt;String&gt; names = Set.of(&quot;Lokesh&quot;, &quot;Amit&quot;, &quot;John&quot;); Map&lt;String, String&gt; names = Map.ofEntries( Map.entry(&quot;1&quot;, &quot;Lokesh&quot;), Map.entry(&quot;2&quot;, &quot;Amit&quot;), Map.entry(&quot;3&quot;, &quot;Brian&quot;)); 6. Java 8 流收集器对于Java 8和更低版本，您可以在Java流的形式中找到类似的用例。 12Set&lt;String&gt; names = Stream.of(&quot;lokesh&quot;, &quot;rohit&quot;, &quot;alex&quot;) .collect( collectingAndThen( toSet(), Collections::unmodifiableSet ) );","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"Initialization","slug":"Initialization","permalink":"http://dangkei.github.io/tags/Initialization/"}]},{"title":"Java的标准IO与新IO有什么区别","slug":"java-standard-IO-vs-new-IO","date":"2021-07-05T07:42:37.000Z","updated":"2021-07-07T06:43:24.050Z","comments":true,"path":"2021/07/05/java-standard-IO-vs-new-IO/","link":"","permalink":"http://dangkei.github.io/2021/07/05/java-standard-IO-vs-new-IO/","excerpt":"","text":"Java Standard IO vs New IO Java 新输入/输出 (NIO)是随 JDK 1.4 引入的。从标准 IO 的角度出发，NIO 为 Java 库提供了高速、面向块的 IO。 通过定义类来保存数据，并通过在块中处理该数据，NIO 以一种java.io包无法使用的方式利用低级优化，而不使用本机代码。 在本文中，我们将重点确定标准 IO 与新 IO 之间最显着的差异，在决定在下一个项目中使用哪个之前，我们必须了解这些差异。 调用标准 IOJava IO是指计算机与世界其他部分之间或单个程序与计算机其他部分之间的接口。 在 Java 编程中，IO 类直到最近才使用流比喻来实现。所有 IO 都被视为单个字节的移动，一次一个，通过名为 a 的对象Stream。 Stream IO 用于联系外界。它也在内部使用，用于将对象转换为字节，然后再转换为对象。它被称为序列化和反序列化。 介绍 Java 新 IOJava NIO 的创建是为了让 Java 程序员无需编写自定义本机代码即可实现高速输入-输出操作。 NIO 将最耗时的 I/O 活动（即填充和排空缓冲区）移回操作系统，从而大大提高速度。 如果以上介绍让您感到口渴，请不要担心，随着我们的前进，您是否会感觉更好。让我们从找出差异开始。 IO 和 NIO 的区别IO 流与 NIO 块标准 IO 库 ( java.io.) 和新 IO ( java.nio.)之间最重要的区别在于数据如何打包并从源传输到目标。如前所述，标准 I/O 处理流中的数据，而 NIO 处理块中的数据。 甲面向流的I / O与数据系统处理的一个或多个字节一次。输入流产生一字节数据，输出流消耗一字节数据。为流数据创建过滤器非常容易。将几个过滤器链接在一起也相对简单，这样每个过滤器都可以在一个复杂的处理机制中发挥作用。 重要的是字节不会缓存在任何地方。此外，我们不能在流中的数据中来回移动。如果您需要在从流中读取的数据中来回移动，我们必须首先将其缓存在缓冲区中。 甲面向块的I / O系统涉及在块中的数据。每个操作在一个步骤中产生或消耗一个数据块。按块处理数据比按（流）字节处理数据快得多。您可以根据需要在缓冲区中前后移动。 数据块在处理过程中为我们提供了更多的灵活性。但是，我们还需要检查缓冲区是否包含我们需要的所有数据，以便完全处理它。并且，我们需要确保在将更多数据读入缓冲区时，我们不会覆盖尚未处理的缓冲区中的数据。 不利的一面是，面向块的 I/O 缺乏面向流 I/O 的一些优雅和简单。 阅读更多：使用 Java NIO 读取文件的 3 种方法 同步标准与异步新 IOJava IO 的各种流都是阻塞的或同步的。这意味着，当一个线程调用read()orwrite()操作时，该线程被阻塞，直到有一些数据要读取，或者数据被完全写入。该线程将在此期间处于阻塞状态。这被认为是在现代语言中引入多线程的一个很好的充分理由。 在异步 IO 中，线程可以请求将某些数据写入通道，但不会等待它完全写入。然后该线程可以继续并同时执行其他操作。通常这些线程在没有被 IO 调用阻塞的时候将它们的空闲时间花在同时在其他通道上执行 IO 上。也就是说，单个线程现在可以管理多个输入和输出通道。 同步程序通常不得不求助于轮询，或者创建很多很多线程来处理大量连接。使用异步 I/O，您可以在任意数量的通道上监听 I/O 事件，无需轮询和额外线程。 异步 I/O 中的中心对象称为Selector。Selector 是您注册对各种 IO 事件感兴趣的地方，它是告诉您这些事件何时发生的对象。所以，我们需要做的第一件事就是创建一个 Selector。 Selector selector = Selector.open();稍后，我们将register()在各种Channel对象上调用该方法，以注册我们对这些对象内部发生的 IO 事件的兴趣。的第一个参数register()始终是Selector。 阅读更多：如何在 Java NIO 中定义路径 Java IO 与 NIO API不用猜测使用 NIO 时的 API 调用看起来与使用 IO 时的不同。在 NIO 中，不是仅仅从例如 an 中读取一个字节的数据字节，而是InputStream必须首先将数据读入 a Buffer，然后从其后进行处理。 使用标准 IO 读取文件的 Java 示例。 123456789101112131415161718192021222324252627282930313233343536&gt;import java.io.BufferedReader;&gt;import java.io.FileReader;&gt;import java.io.IOException;&gt;public class WithoutNIOExample&gt;&#123; public static void main(String[] args) &#123; BufferedReader br = null; String sCurrentLine = null; try &#123; br = new BufferedReader( new FileReader(&quot;test.txt&quot;)); while ((sCurrentLine = br.readLine()) != null) &#123; System.out.println(sCurrentLine); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (br != null) br.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;&gt;&#125; 使用 New IO 读取文件的 Java 示例。 1234567891011121314151617181920212223242526&gt;import java.io.IOException;&gt;import java.io.RandomAccessFile;&gt;import java.nio.ByteBuffer;&gt;import java.nio.channels.FileChannel;&gt;public class ReadFileWithFixedSizeBuffer&gt;&#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile aFile = new RandomAccessFile (&quot;test.txt&quot;, &quot;r&quot;); FileChannel inChannel = aFile.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while(inChannel.read(buffer) &gt; 0) &#123; buffer.flip(); for (int i = 0; i &lt; buffer.limit(); i++) &#123; System.out.print((char) buffer.get()); &#125; buffer.clear(); // do something with the data and clear/compact it. &#125; inChannel.close(); aFile.close(); &#125;&gt;&#125; 结论NIO 允许您仅使用单个（或更少）线程来管理多个通道，但代价是解析数据可能比使用标准 IO 从阻塞流中读取数据要复杂一些。 如果您需要同时管理数千个打开的连接，每个连接只发送少量数据，例如聊天服务器，在 NIO 中实现服务器可能是一个优势。同样，如果您需要与其他计算机保持大量开放连接，例如在 P2P 网络中，使用单个线程来管理所有出站连接可能是一个优势。 如果您的连接较少且带宽非常高，一次发送大量数据，则应该选择标准 IO 服务器实现。 本文翻译自：https://howtodoinjava.com/java/io/difference-between-io-nio/","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"}]},{"title":"Java IO内部是如何工作的?","slug":"how-java-io-work","date":"2021-07-01T08:17:34.000Z","updated":"2021-07-06T07:27:12.478Z","comments":true,"path":"2021/07/01/how-java-io-work/","link":"","permalink":"http://dangkei.github.io/2021/07/01/how-java-io-work/","excerpt":"","text":"本文旨在为那些好奇知道如何在机器级别映射Java IO操作以及在应用程序运行时硬件始终做什么的读者编写。 我假设您熟悉基本的IO操作，例如读取文件、通过JavaIO API编写文件；因为这超出了本文的范围。 缓冲区处理和内核与用户空间“input/output”一词只意味着将数据移出缓冲区。 缓冲区以及缓冲区的处理方式是所有IO的基础。你只要时刻记住这个。 通常，进程通过请求操作系统从缓冲区（写入操作）中排出数据或用数据填充缓冲区（读取操作）来执行IO。这是IO概念的全部总结。 操作系统中执行这些传输的机器可能非常复杂，但从概念上讲，它非常简单，我们将在本文中讨论其中的一小部分。 os级的数据缓冲 上图显示了块数据如何从外部源（例如硬盘）移动到正在运行的进程（例如RAM）内的内存区域的简化“逻辑”图。 首先，进程请求通过调用read（）系统来填充其缓冲区。 读调用导致内核向磁盘控制器硬件发出命令，以从磁盘中获取数据。 磁盘控制器通过DMA直接将数据写入内核内存缓冲区，而不需要主CPU的进一步帮助。 磁盘控制器完成缓冲区填充后，内核将数据从内核空间中的临时缓冲区复制到进程指定的缓冲区；当请求read（）操作时。 需要注意的一点是内核试图缓存和/或预取数据，因此进程请求的数据可能已经在内核空间中可用。如果是，则将复制流程请求的数据。 如果数据不可用，则进程将暂停，而内核则将数据带入内存。 虚拟内存 您一定已经多次听说过虚拟内存。让我想想。 所有现代操作系统都利用虚拟内存。虚拟内存是指人工地址或虚拟地址被用来代替物理（硬件RAM）内存地址。 虚拟内存带来两个重要优势： 多个虚拟地址可以引用相同的物理内存位置。 虚拟内存空间可以大于实际可用硬件内存。 在前面的部分中，从内核空间复制到最终用户缓冲区似乎是额外的工作。为什么不告诉磁盘控制器直接发送到userspace中的缓冲区？好吧，它是用虚拟内存完成的，这是上面的优势1。 通过将内核空间地址映射到与用户空间中的虚拟地址相同的物理地址，DMA硬件（只能访问物理内存地址）可以填充内核和用户空间进程同时可见的缓冲区。 这消除了内核和用户空间之间的拷贝，但需要内核和用户缓冲区共享相同的页面对齐方式。缓冲区还必须是磁盘控制器使用的块大小的倍数（通常是512字节磁盘扇区）。 操作系统将内存地址空间划分为页，页是固定大小的字节组。这些内存页总是磁盘块大小的倍数，通常是2的幂（这简化了寻址）。典型的内存页大小是1024、2048和4096字节。 虚拟内存页和物理内存页的大小总是相同的。 内存分页 为了支持虚拟内存的第二个优点（可寻址空间大于物理内存），有必要进行虚拟内存分页（通常称为交换）。 内存分页是一种方案，通过这种方案，虚拟内存空间的页面可以持久化到外部磁盘存储器中，以便在物理内存中为其他虚拟页面腾出空间。从本质上讲，物理内存充当分页区域的缓存，分页区域是磁盘上的空间，当物理内存被挤出时，存储内存页的内容。 将内存页大小调整为磁盘块大小的倍数允许内核向磁盘控制器硬件发出直接命令，将内存页写入磁盘或在需要时重新加载它们。 原来，所有磁盘IO都是在页面级别完成的。在现代的分页操作系统中，这是数据在磁盘和物理内存之间移动的唯一方式。 现代CPU包含一个子系统，称为内存管理单元（MMU）。这个设备在逻辑上位于CPU和物理内存之间。MMU包含将虚拟地址转换为物理内存地址所需的映射信息。 当CPU引用内存位置时，MMU确定该位置所在的页（通常通过移动或屏蔽地址值的位）并将该虚拟页号转换为物理页号（这在硬件中完成，并且非常快）。 面向文件/块的IO 文件IO总是发生在文件系统的上下文中。文件系统与磁盘截然不同。磁盘将数据存储在扇区中，每个扇区通常为512字节。它们是对文件的语义一无所知的硬件设备。它们只是提供了一些可以存储数据的插槽。在这方面，磁盘的扇区类似于内存页；所有扇区的大小都是一致的，并且可以作为一个大数组寻址。 另一方面，文件系统是更高层次的抽象。文件系统是一种特殊的方法，用于排列和解释存储在磁盘（或其他一些随机存取、面向块的设备）上的数据。您编写的代码几乎总是与文件系统交互，而不是直接与磁盘交互。文件系统定义了文件名、路径、文件、文件属性等的抽象。 文件系统（在硬盘中）组织一系列大小一致的数据块。一些块存储元信息，如空闲块、目录、索引等的映射。其他块包含实际的文件数据。 有关单个文件的元信息描述了哪些块包含文件数据、数据结束的位置、上次更新的时间等。 当用户进程请求读取文件数据时，文件系统实现会准确地确定数据在磁盘上的位置。然后它采取措施将这些磁盘扇区放入内存。 文件系统也有页的概念，页的大小可以是基本内存页的大小，也可以是基本内存页的倍数。典型的文件系统页面大小从2048字节到8192字节不等，并且总是基本内存页面大小的倍数。 分页文件系统如何执行IO归结为以下逻辑步骤： 确定请求跨越的文件系统页（磁盘扇区组）。磁盘上的文件内容和/或元数据可能分布在多个文件系统页面上，这些页面可能是不连续的。 在内核空间中分配足够的内存页以容纳已标识的文件系统页。 在这些内存页和磁盘上的文件系统页之间建立映射。 为每个内存页生成页错误。 虚拟内存系统捕获页面错误并调度pagein（即分页空间pagein），通过从磁盘读取页面内容来验证这些页面。 一旦pagein完成，文件系统就会分解原始数据以提取请求的文件内容或属性信息。 注意，这个文件系统数据将像其他内存页一样被缓存。在随后的IO请求中，部分或全部文件数据可能仍存在于物理内存中，并且可以重用，而无需从磁盘重新读取 文件锁定 文件锁定是一种方案，通过该方案，一个进程可以阻止其他进程访问某个文件或限制其他进程访问该文件的方式。虽然“文件锁定”这个名称意味着锁定整个文件（通常是这样做的），但锁定通常在更细粒度的级别上可用。 文件区域通常是锁定的，粒度降低到字节级别。锁与特定文件相关联，从该文件中的特定字节位置开始，并在特定的字节范围内运行。这一点很重要，因为它允许许多进程协调对文件特定区域的访问，而不会妨碍文件中其他进程的工作。 文件锁有两种类型：共享锁和独占锁。多个共享锁可能同时对同一文件区域有效。另一方面，独占锁要求没有其他锁对请求的区域有效。 流IO 并非所有IO都是面向块的。还有流IO，它是基于管道建模的。必须按顺序访问IO流的字节。TTY（控制台）设备、打印机端口和网络连接是流的常见示例。 流通常（但不一定）比块设备慢，并且通常是间歇输入的源。大多数操作系统允许将流置于非阻塞模式，这允许进程检查流上的输入是否可用，如果此时没有可用的输入，则不会卡住。这样的功能允许进程在输入到达时处理输入，但在输入流空闲时执行其他功能。 超越非阻塞模式的一个步骤是能够进行就绪选择。这类似于非阻塞模式（并且通常构建在非阻塞模式之上），但是减轻了对流是否准备好用于操作系统的检查。 可以告诉操作系统监视流的集合，并向进程返回指示哪些流已就绪。这种能力允许进程利用操作系统返回的就绪信息，使用公共代码和单个线程多路复用多个活动流。 流IO在网络服务器中被广泛用于处理大量的网络连接。准备就绪选择对于高容量扩展至关重要。 这些都是关于这个有大量技术词汇的非常复杂的话题🙂","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"}]},{"title":"静态导入声明的一些重要规则","slug":"import-rules","date":"2021-07-01T07:59:18.000Z","updated":"2021-07-06T08:08:07.770Z","comments":true,"path":"2021/07/01/import-rules/","link":"","permalink":"http://dangkei.github.io/2021/07/01/import-rules/","excerpt":"","text":"import static静态导入是JDK1.5中的新特性。一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.;这里的多了个static，还有就是类名ClassName后面多了个 . ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便 下面是关于静态导入声明的一些重要规则。 1） 如果导入两个具有相同简单名称的静态成员，一个使用单个静态导入声明，另一个使用静态按需导入声明，则使用单个静态导入声明导入的静态成员优先。 假设有两个类，package1.Class1和package2.Class2。两个类都有一个名为methodA的静态方法。以下代码将使用package1.Class1.methodA（）方法，因为它是使用单个静态导入声明导入的： 12345678&gt;import static package1.Class1.methodA; // Imports Class1.methodA() method&gt;import static package2.Class2.*; // Imports Class2.methodA() method too &gt;public class Test &#123; public static void main(String[] args) &#123; methodA(); // Class1.methodA() will be called &#125;&gt;&#125; 2） 不允许使用单个静态导入声明导入两个具有相同简单名称的静态成员。以下静态导入声明生成错误，因为它们都使用相同的简单名称methodA导入静态成员： 12&gt;import static package1.Class1.methodA;&gt;import static package1.Class2.methodA; // An error 3） 如果使用单个静态导入声明导入静态成员，并且同一类中存在同名的静态成员，则该类中的静态成员将被使用。 123456789101112131415161718192021222324252627&gt;// A.java&gt;package package1; &gt;public class A &#123; public static void test() &#123; System.out.println(&quot;package1.A.test()&quot;); &#125;&gt;&#125; &gt;// Test.java&gt;package package2; &gt;import static package1.A.test; &gt;public class Test &#123; public static void main(String[] args) &#123; test(); // Will use package2.Test.test() method, not package1.A.test() method &#125; public static void test() &#123; System.out.println(&quot;package2.Test.test()&quot;); &#125;&gt;&#125;&gt;Output:&gt;package2.Test.test() 静态导入似乎可以帮助您使用静态成员的简单名称，从而使程序更易于编写和读取。有时静态导入可能会在程序中引入细微的错误，这可能很难调试。建议您完全不要使用静态导入，或者仅在非常罕见的情况下使用。","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"static","slug":"static","permalink":"http://dangkei.github.io/tags/static/"},{"name":"import","slug":"import","permalink":"http://dangkei.github.io/tags/import/"}]},{"title":"Hello hexo github","slug":"hello-world","date":"2021-07-01T06:15:22.557Z","updated":"2021-07-12T08:03:50.395Z","comments":true,"path":"2021/07/01/hello-world/","link":"","permalink":"http://dangkei.github.io/2021/07/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server123$ hexo server //or$ hexo s More info: Server Generate static files123$ hexo generate//or$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy//or$ hexo d More info: Deployment config local git123git config –global user.name yournamegit config –global user.email youremail generated your login secrtkey1Ssh-keygen -t rsa -C yourname@mail.com","categories":[{"name":"hexo","slug":"hexo","permalink":"http://dangkei.github.io/categories/hexo/"}],"tags":[]}],"categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"},{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"},{"name":"hexo","slug":"hexo","permalink":"http://dangkei.github.io/categories/hexo/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"},{"name":"lambda","slug":"lambda","permalink":"http://dangkei.github.io/tags/lambda/"},{"name":"redis","slug":"redis","permalink":"http://dangkei.github.io/tags/redis/"},{"name":"Initialization","slug":"Initialization","permalink":"http://dangkei.github.io/tags/Initialization/"},{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"},{"name":"static","slug":"static","permalink":"http://dangkei.github.io/tags/static/"},{"name":"import","slug":"import","permalink":"http://dangkei.github.io/tags/import/"}]}