{"meta":{"title":"Bomblebee","subtitle":"","description":"","author":"Huang Feng","url":"http://dangkei.github.io","root":"/"},"pages":[{"title":"书单","date":"2021-07-01T06:15:40.121Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"http://dangkei.github.io/books/index.html","excerpt":"","text":""},{"title":"关于dangkei","date":"2021-07-30T11:05:21.069Z","updated":"2021-07-30T11:05:21.069Z","comments":false,"path":"about/index.html","permalink":"http://dangkei.github.io/about/index.html","excerpt":"","text":"2021-07-01 建党100周年纪念日 看到一个好的主题pure，感觉非常不错就换了，非常感谢这个主题的作者，虽然更新后很多内容都没有了， 不过还好有备份。 有时间慢慢恢复吧。自己已经是一个大龄程序员了， 走过很长一段人生路， 对生命，生活， 亲情，爱情，家庭都有了一些新的认知。 希望今后的道路上让编程重新成为自己的爱好而不止是谋生的手段， 重拾自己对技术的兴趣。 也希望自己身边的人都健康，快乐。 ——个人详细介绍—— 履历时间线  2019年3月——至今 航天四创科技有限责任公司 高级软件开发工程师  8月16日 杜甫的思想核心是儒家的仁政思想，他有“致君尧舜上，再使风俗淳”的宏伟抱负。个人最爱的名篇有： 《登高》 《茅屋为秋风所破歌》  8月15日 中国人民抗日战争胜利日 铭记、感恩 所有为中华民族浴血奋战的英雄将士 永垂不朽  过去"},{"title":"友情链接","date":"2021-07-01T06:15:40.124Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"http://dangkei.github.io/links/index.html","excerpt":"","text":""},{"title":"项目库","date":"2021-07-01T07:53:18.384Z","updated":"2021-07-01T07:53:18.384Z","comments":false,"path":"repository/index.html","permalink":"http://dangkei.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-05T07:35:42.586Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://dangkei.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-01T06:15:40.204Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"http://dangkei.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-07-29T03:43:12.588Z","updated":"2021-07-29T03:43:12.588Z","comments":false,"path":"/404.html","permalink":"http://dangkei.github.io/404.html","excerpt":"","text":"中国奥运健儿！加油！"}],"posts":[{"title":"漂亮的javascript代码？易读还是难读？","slug":"code-optimization-js","date":"2021-07-28T03:38:00.000Z","updated":"2021-07-29T03:02:50.186Z","comments":true,"path":"2021/07/28/code-optimization-js/","link":"","permalink":"http://dangkei.github.io/2021/07/28/code-optimization-js/","excerpt":"","text":"javascript 优化if 使用if嵌套的代码 注释: content是一个包含文档所有内容的json对象。 123456789if(status==null)&#123; statusName=&quot;办理中&quot;;&#125;else&#123; if(status==&quot;3&quot;)&#123; statusName=&quot;通过&quot;; else&#123; statusName=content.statusName; &#125;&#125; 逻辑分析, 这是一段简单判断显示流程状态的代码。 如果状态代码 status==null 中文状态显示’办理中 如果status不为null status==3的情况下 中文状态显示’通过’，否则显示statusName本身值。 1. 换做三元表达式改写： “Write less, do more.” 123status==null?statusName=&quot;办理中&quot;: status==&quot;3&quot;?statusName=&quot;通过&quot;: statusName=content.statusName; 代码是不是清爽了很多? tips 回车只是为了阅读代码方便，这并不是3行代码而是一行，:前的语句最后不能加``;`. 2. 换做switch改xie12345678910111213switch(statusName)&#123; case null: statusName = &quot;办理中&quot;; break; default: switch(status)&#123; case &quot;3&quot;: statusName = &quot;通过&quot;; break; default: statusName = content.statusName; &#125;&#125; 这个例子转换为switch还是复杂。 所以使用什么方式转换还是要看实际情况。希望大家都能写出自己喜欢更加优雅的代码！ tips switch 使用严格匹配=== 下面的例子case 0不会匹配 12345678var x=&quot;0&quot;;switch(x)&#123; case 0: .... break; default: ....&#125;","categories":[{"name":"coding","slug":"coding","permalink":"http://dangkei.github.io/categories/coding/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://dangkei.github.io/tags/javascript/"}]},{"title":"how to use docker (9) images layer and cached","slug":"how-to-use-docker-9","date":"2021-07-23T02:02:35.000Z","updated":"2021-07-23T09:03:00.204Z","comments":true,"path":"2021/07/23/how-to-use-docker-9/","link":"","permalink":"http://dangkei.github.io/2021/07/23/how-to-use-docker-9/","excerpt":"","text":"学习docker最佳实践镜像分层您知道吗，您可以查看镜像的构成要素？使用该docker image history命令，您可以查看用于在镜像中创建每个图层的命令。 使用该docker image history命令查看dockerapp您在本教程前面创建的镜像中的图层。 docker image history docekrapp您应该得到类似这样的输出（日期/ID 可能不同）。 1234567891011121314151617E:\\code\\blog\\Blog&gt;docker image history dangkei/dockerappIMAGE CREATED CREATED BY SIZE COMMENTe79ba6df98b4 3 days ago CMD [&quot;node&quot; &quot;src/index.js&quot;] 0B buildkit.dockerfile.v0&lt;missing&gt; 3 days ago RUN /bin/sh -c yarn install --production # b… 85.2MB buildkit.dockerfile.v0&lt;missing&gt; 3 days ago COPY . . # buildkit 4.62MB buildkit.dockerfile.v0&lt;missing&gt; 3 days ago WORKDIR /dockerapp 0B buildkit.dockerfile.v0&lt;missing&gt; 4 days ago RUN /bin/sh -c apk add --no-cache python g++… 205MB buildkit.dockerfile.v0&lt;missing&gt; 4 days ago MAINTAINER Docker dangkei &lt;dangkei@163.com&gt; 0B buildkit.dockerfile.v0&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) CMD [&quot;node&quot;] 0B&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) ENTRYPOINT [&quot;docker-entry… 0B&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) COPY file:238737301d473041… 116B&lt;missing&gt; 2 weeks ago /bin/sh -c apk add --no-cache --virtual .bui… 7.62MB&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) ENV YARN_VERSION=1.22.5 0B&lt;missing&gt; 2 weeks ago /bin/sh -c addgroup -g 1000 node &amp;&amp; addu… 75.7MB&lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) ENV NODE_VERSION=12.22.3 0B&lt;missing&gt; 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot;] 0B&lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:282b9d56236cae296… 5.62MB 每条线代表镜像中的一个层。此处的显示在底部显示底部，在顶部显示最新层。使用它，您还可以快速查看每一层的大小，帮助诊断大镜像。 您会注意到有几行被截断了。如果你添加–no-trunc标志，你会得到完整的输出（是的……有趣的是你如何使用截断的标志来获得未截断的输出，是吧？） 1docker image history --no-trunc dangkei/dockerapp 层缓存 既然您已经看到了分层的作用，那么有一个重要的知识需要你来学习帮助减少容器镜像的构建时间。首先一旦层发生变化，所有下游层也必须重新创建让我们再看一次我们使用的 Dockerfile… 12345678# This is a comment FROM node:12-alpine MAINTAINER Docker dangkei &lt;dangkei@163.com&gt;RUN apk add --no-cache python g++ makeWORKDIR /dockerappCOPY . .RUN yarn install --productionCMD [&quot;node&quot;, &quot;src/index.js&quot;] 当我们更新我们的应用重新创建镜像时 1234567891011121314151617E:\\code\\dockerapp&gt;docker build -f dockerfile -t dockerapp .[+] Building 119.9s (9/9) FINISHED =&gt; [internal] load build definition from dockerfile-copy 1.8s =&gt; =&gt; transferring dockerfile: 263B 0.0s =&gt; [internal] load .dockerignore 2.7s =&gt; =&gt; transferring context: 34B 0.0s =&gt; [internal] load metadata for docker.io/library/node:12-alpine 0.0s =&gt; [1/4] FROM docker.io/library/node:12-alpine 0.0s =&gt; [internal] load build context 1.2s =&gt; =&gt; transferring context: 2.85kB 0.0s =&gt; CACHED [2/4] WORKDIR /dockerapp 0.2s =&gt; [3/4] COPY . . 2.3s =&gt; [4/4] RUN yarn install --production 105.6s =&gt; exporting to image 6.3s =&gt; =&gt; exporting layers 5.0s =&gt; =&gt; writing image sha256:729ecf2798f37b7c1f8d9229c8f985e2c8851514a072d0cb6668f41b5c36157a 0.2s =&gt; =&gt; naming to docker.io/library/dockerapp 0.2s 回到镜像历史输出，我们看到 Dockerfile 中的每个命令都变成了镜像中的一个新层。您可能还记得，当我们对映像进行更改时，必须重新安装yarn依赖项。有没有办法解决这个问题？每次构建时都传递相同的依赖关系没有多大意义，对吧？注意： 1=&gt; [4/4] RUN yarn install --production 105.6s 每次重新构建镜像都要105.6，如果分层多，层又很大的话真时很浪费时间。为了解决这个问题，我们需要重构我们的 Dockerfile 以帮助支持依赖项的缓存。对于基于节点的应用程序，这些依赖项在package.json文件中定义。那么，如果我们先只复制那个文件，安装依赖项，然后再复制其他所有东西呢？然后，我们只在 .yaml 文件发生更改时重新创建yarn依赖项package.json。有道理吗？ 更新 Dockerfile 以package.json首先复制，安装依赖项，然后复制其他所有内容。 123456789# This is a comment FROM node:12-alpine MAINTAINER Docker dangkei &lt;dangkei@163.com&gt;WORKDIR /dockerappCOPY package.json yarn.lock ./RUN yarn install --productionCOPY . .CMD [&quot;node&quot;, &quot;src/index.js&quot;] .dockerignore使用以下内容在与 Dockerfile 相同的文件夹中创建一个文件。 1node_modules .dockerignore文件是有选择地仅复制镜像相关文件的简单方法。您可以在此处阅读更多相关信息。在这种情况下，node_modules应在COPY第二步中省略该文件夹，否则可能会覆盖由该RUN步骤中的命令创建的文件。有关为什么建议将其用于 Node.js 应用程序和其他最佳实践的更多详细信息，请查看他们关于Dockerizing a Node.js Web 应用程序的指南。 现在docker build -t dockerapp .再次使用构建 Docker镜像。这一次，您的输出应该看起来有点不同。 使用docker build. 看到下面的输出 123456789101112131415161718E:\\code\\dockerapp&gt;docker build -f dockerfile -t dockerapp .[+] Building 11.8s (10/10) FINISHED =&gt; [internal] load build definition from dockerfile 1.9s =&gt; =&gt; transferring dockerfile: 253B 0.0s =&gt; [internal] load .dockerignore 2.7s =&gt; =&gt; transferring context: 34B 0.0s =&gt; [internal] load metadata for docker.io/library/node:12-alpine 0.0s =&gt; [1/5] FROM docker.io/library/node:12-alpine 0.0s =&gt; [internal] load build context 1.3s =&gt; =&gt; transferring context: 2.62kB 0.0s =&gt; CACHED [2/5] WORKDIR /dockerapp 0.0s =&gt; CACHED [3/5] COPY package.json yarn.lock ./ 0.0s =&gt; CACHED [4/5] RUN yarn install --production 0.0s =&gt; [5/5] COPY . . 2.2s =&gt; exporting to image 4.0s =&gt; =&gt; exporting layers 2.5s =&gt; =&gt; writing image sha256:82f9d29c08aaf923900c9ed401965923ee94906d338541ecd60e03e6fce00baa 0.2s =&gt; =&gt; naming to docker.io/library/dockerapp 0.2s 您会看到所有图层都已重建。非常好，因为我们对 Dockerfile 进行了相当多的更改。 首先，您应该注意到构建速度要快得多！而且，您会看到步骤 1=&gt; CACHED [4/5] RUN yarn install --production 0.0s 0秒已缓存，万岁！我们正在使用构建缓存。推送和拉取此镜像并对其进行更新也会更快。万岁！ 多阶段构建虽然我们不会在本教程中深入探讨它，但多阶段构建是一个非常强大的工具，可以帮助使用多个阶段来创建镜像。它们有几个优点： 将构建时依赖项与运行时依赖项分开通过仅传送您的应用程序需要运行的内容来减少整体镜像大小Maven/Tomcat 示例在构建基于 Java 的应用程序时，需要 JDK 将源代码编译为 Java 字节码。但是，生产中不需要该 JDK。此外，您可能会使用 Maven 或 Gradle 等工具来帮助构建应用程序。在我们的最终镜像中也不需要这些。多阶段构建帮助。 1234567FROM maven AS buildWORKDIR /appCOPY . .RUN mvn packageFROM tomcatCOPY --from=build /app/target/file.war /usr/local/tomcat/webapps 在此示例中，我们使用一个阶段（称为build）来使用 Maven 执行实际的 Java 构建。在第二阶段（从 开始FROM tomcat），我们从build阶段复制文件。最终镜像只是正在创建的最后一个阶段（可以使用–target标志覆盖）。 反应示例在构建 React 应用程序时，我们需要一个 Node 环境来将 JS 代码（通常是 JSX）、SASS 样式表等编译成静态 HTML、JS 和 CSS。如果我们不进行服务器端渲染，我们甚至不需要用于生产构建的 Node 环境。为什么不在静态 nginx 容器中传送静态资源？ 12345678910FROM node:12 AS buildWORKDIR /appCOPY package* yarn.lock ./RUN yarn installCOPY public ./publicCOPY src ./srcRUN yarn run buildFROM nginx:alpineCOPY --from=build /app/build /usr/share/nginx/html 在这里，我们使用node:12镜像来执行构建（最大化层缓存），然后将输出复制到 nginx 容器中。很酷吧？ 回顾通过稍微了解镜像的结构，我们可以更快地构建镜像并减少更改。扫描镜像让我们相信我们正在运行和分发的容器是安全的。多阶段构建还通过将构建时依赖项与运行时依赖项分开来帮助我们减少整体镜像大小并提高最终容器的安全性。","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (8) user docker compose build application","slug":"how-to-use-docker-8","date":"2021-07-22T05:41:51.000Z","updated":"2021-07-23T06:38:35.693Z","comments":true,"path":"2021/07/22/how-to-use-docker-8/","link":"","permalink":"http://dangkei.github.io/2021/07/22/how-to-use-docker-8/","excerpt":"","text":"Docker Compose是一种工具，旨在帮助定义和共享多容器应用程序。使用 Compose，我们可以创建一个 YAML 文件来定义服务，并且可以使用单个命令来启动或拆除所有内容。 使用 Compose的一大优势是您可以在文件中定义应用程序集，将其保存在项目存储库的根目录下（现在受版本控制），并且可以轻松地让其他人为您的项目做出贡献。有人只需要克隆您的存储库并启动撰写应用程序。事实上，你现在可能会在 GitHub/GitLab 上看到很多项目就是这样做的。 > 我们这里以前面dockerapp 和mysql两个应用为例子使用compose将他们配置为一个应用程序集 查看版本使用命令docker-compose version查看compose版本信息 得到结果 12E:\\code&gt;docker compose versionDocker Compose version v2.0.0-beta.6 创建文件docker-compose.yml还是以之前项目为例创建文件E:\\code\\dockerapp\\docker-compose.yml 并且用文本编辑器打开开始编辑 第一行标注compose版本信息1version: v2.0.0-beta.6 定义应用程序集的所有服务配置也就是所有容器配置我们这里需要配置两个服务dockerapp和mysql12345version: v2.0.0-beta.6services: dockerapp: mysql: 接下来具体配置dockerapp1234567891011121314151617version: v2.0.0-beta.6services: dockerapp: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - &quot;3000:3000&quot; working_dir: /dockerapp volumes: - ./:/dockerapp environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: 123456 MYSQL_DB: todos mysql: 再配置mysql容器信息123456789101112131415161718192021222324version: v2.0.0-beta.6services: dockerapp: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - &quot;3000:3000&quot; working_dir: /dockerapp volumes: - ./:/dockerapp environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: 123456 MYSQL_DB: todos mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: todos volumes: - D:\\docker\\mysql3306\\data:/var/lib/mysql - D:\\docker\\mysql3306\\conf:/etc/mysql/conf.d 生成应用集 回到应用根目录下的命令行状态1234E:\\code\\dockerapp&gt;docker compose up -d[+] Running 2/2 - Container dockerapp_mysql_1 Started 9.3s - Container dockerapp_dockerapp_1 Started 9.1s 提示命令执行成功 测试结果打开浏览器http://localhost:3000 依然看到之前的dockerapp成功展示出来。 问题与回顾 虽然文章结果程序直接运行成功，实际中间经历很多波折，遇到很多坑， 通过一步步百度搜索最终问题全部解决，现在 把自己在这一过程中遇到的问题分享给大家。 compose版本","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (7)- Multi-Container-App","slug":"how-to-use-docker-7","date":"2021-07-21T08:27:29.000Z","updated":"2021-07-29T06:35:59.988Z","comments":true,"path":"2021/07/21/how-to-use-docker-7/","link":"","permalink":"http://dangkei.github.io/2021/07/21/how-to-use-docker-7/","excerpt":"","text":"多容器应用 到目前为止，我们一直在使用单容器应用程序。但是，我们现在想要将 MySQL添加到应用程序中。经常会出现下面的问题——“MySQL会在哪里运行？安装在同一个容器中还是单独运行？” 一般来说， 每个容器应该做一件事，并且做好。 几个原因： 您很有可能必须以不同于数据库的方式扩展 API 和前端 单独的容器让您可以隔离地版本和更新版本 虽然您可以在本地为数据库使用容器，但您可能希望在生产中为数据库使用托管服务。你不想在你的应用程序中发布你的数据库引擎。 运行多个进程将需要一个进程管理器（容器只启动一个进程），这增加了容器启动/关闭的复杂性 容器网络请记住，默认情况下，容器是独立运行的，并且对同一台机器上的其他进程或容器一无所知。那么，我们如何让一个容器与另一个容器通信呢？答案是网络。现在，您不必成为网络工程师（万岁！）。只要记住这个规则……如果两个容器在同一个网络上，它们可以相互通信。如果他们不是，他们就不能。输入docker命令 docker network –help 我们可以看到 12345678Commands: connect 连接一个容器到一个网络 create 创建一个网络 disconnect 将一个容器从一个网络中断开 inspect 显示一个或多个网络的详细信息 ls 列出所有的网络 prune 删除所有没用的网络 rm 删除一个或多个网络 最小之前的应用dockerapp 现在我们要让她使用另一个容器里的mysql数据库，遵循上面的规则，我们要做一些事情。 创建容器网络让我们为之前的dockerapp 也就是(todo-list)应用创建网络 1docker network create todo-net 使用网络创建mysql容器1docker run -dp 3306:3306 --network todo-net --network-alias mysql --name mysql -v D:\\docker\\mysql3306\\conf:/etc/mysql/conf.d -v D:\\docker\\mysql3306\\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=todos mysql:5.7.25 重新创建dockerapp应用容器。 让我们使用todo-net网络重新创建一下之前的dockerapp应用使用刚刚创建的mysql容器中的todos数据库。 1docker run -dp 3000:3000 -w /dockerapp --network todo-net -e MYSQL_HOST=mysql -e MYSQL_USER=root -e MYSQL_PASSWORD=123456 -e MYSQL_DB=todos dangkei/dockerapp 12345--network todo-net # 使用todo-net网络-e MYSQL_HOST=mysql # mysql主机名称-e MYSQL_USER=root # mysql登陆用户名-e MYSQL_PASSWORD=123456 # mysql登陆密码 -e MYSQL_DB=todos # 应用使用数据库名 测试结果 测试一下： 打开浏览器 http/localhost:3000/ 看到应用界面，如果没用查看容器日志检查问题，然后插入两条测试数据再打开命令行执行下面语句 1docker exec -it mysql mysql -p todos 第一个个mysql 是容器名称 第二个是登陆容器后执行命令 mysql 参数 -p toddos 使用数据库 todos 成功后查询数据结果 12345678mysql&gt; select * from todo_items ;+--------------------------------------+--------------+-----------+| id | name | completed |+--------------------------------------+--------------+-----------+| f5f2c90a-f5a3-45b7-b0a8-6fabd05286d4 | test | 0 || e4fe0fd5-9af3-44b8-b26c-edee17238970 | study docker | 0 |+--------------------------------------+--------------+-----------+2 rows in set (0.00 sec) 可以看到测试的数据已经保存到数据库中。 使用–link参数 很多时候我们默认创建mysql并没有指定network 我们应用要是连接mysql容器可以之间使用–link参数 1docker run -dp 3000:3000 -w /dockerapp --name todo-lis --link mysql:mysql -e MYSQL_HOST=mysql -e MYSQL_USER=root -e MYSQL_PASSWORD=123456 -e MYSQL_DB=todos dangkei/dockerapp –link mysql:mysql 中第一个mysql是mysql容器名称 第二个mysql是别名。","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (6) Persisting-Your-Data","slug":"how-to-use-docker-6","date":"2021-07-20T02:39:29.000Z","updated":"2021-07-23T07:05:57.783Z","comments":true,"path":"2021/07/20/how-to-use-docker-6/","link":"","permalink":"http://dangkei.github.io/2021/07/20/how-to-use-docker-6/","excerpt":"","text":"Persisting our Data卷的概念（Container Volumes） 个人理解卷（volume）就是容器运行时挂载的主机上的磁盘空间 容器挂载的几种方式： named volumes方式 最常用的方式 docker帮我们创建容器时创建，默认保存位置在 /var/lib/docker/volumes 目录中； bind Mount 比较常用的方式，绑定挂载就是创建容器时候 使用了 -v 参数指定主机上的目录， 但是移植可能不同操作系统可能会不兼容。比如window和linux操作系统之间 tmpfs 一般不会用， 挂载在宿主机的内存中的方式 卷的管理123# docker volume create dockerapp-vol // 创建一个自定义容器卷# docker volume ls // 查看所有容器卷# docker volume inspect dockerapp-vol // 查看指定容器卷详情信息 持久化应用让我们来持久化我们的 dockapp 数据默认情况下，dockapp 应用程序将其数据存储在SQLite 数据库中/etc/todos/todo.db。如果您不熟悉 SQLite，不用担心！它只是一个关系数据库，其中所有数据都存储在一个文件中。虽然这对于大型应用程序来说不是最好的，但它适用于小型演示。稍后我们将讨论将其切换到不同的数据库引擎。 由于数据库是单个文件，如果我们可以在主机上保留该文件并使其可用于下一个容器，它应该能够从上一个停止的地方继续。通过创建一个卷并将其附加（通常称为“挂载”）到存储数据的目录，我们可以持久化数据。当我们的容器写入todo.db文件时，它将被持久化到卷中的主机。 如前所述，我们将使用命名卷。将命名卷视为简单的数据桶。Docker 维护磁盘上的物理位置，您只需要记住卷的名称。每次使用该卷时，Docker 都会确保提供正确的数据。 使用docker volume create命令创建卷。 1docker volume create dockerapp-vol 在仪表板中（或使用docker rm -f ）再次停止待办事项应用程序容器，因为它仍在运行而不使用持久卷。 启动 dockerapp 应用程序容器，但添加-v标志以指定卷安装。我们将使用命名卷并将其挂载到/etc/todos，这将捕获在路径上创建的所有文件。 1docker run -dp 3000:3000 -v dockerapp-vol:/etc/todos dockerapp 容器启动后，打开应用程序并将一些项目添加到您的待办事项列表中。 添加到待办事项列表的项目 移除 dockerapp 应用的容器。使用仪表板 或docker ps获取 ID，然后docker rm -f 将其删除。 使用与上面相同的命令启动一个新容器。 打开应用程序。您应该会看到您之前加入的项目仍在您的列表中！ 完成检查列表后，继续并移除容器。","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (5) - share your images","slug":"how-to-use-docker-5","date":"2021-07-20T01:32:46.000Z","updated":"2021-07-23T09:02:36.683Z","comments":true,"path":"2021/07/20/how-to-use-docker-5/","link":"","permalink":"http://dangkei.github.io/2021/07/20/how-to-use-docker-5/","excerpt":"","text":"分享自己的镜像创建docker仓库 要想分享我们创建的镜像首先我们要到docker hub网站上面注册账户并登陆。 点击Create Repository按钮 仓库名称 这里使用 dockerapp. 并且确认可见权限为Public 点击 create 按钮。 如果创建成功，在页面右边你会看到一个 * Docker commands * 区域以我创建的镜像为例。 1docker push dangkei/dockerapp:tagname 在这里dangkei是我注册的docker hub时的用户名 推送镜像到仓库 看样子是只要把仓库给我的docker命令直接执行就可以完成了。其实并不是这样。当在本地主机上执行此命令后 123E:\\code\\blog\\Blog&gt;docker push dangkei/dockerappThe push refers to repository [docker.io/dangkei/dockerapp]An image does not exist locally with the tag: dangkei/dockerapp 从提示心心可以看到， 本地时没有dangkei/dockerapp这个镜像，所以我们要先修改一下镜像名称 1docker tag dockerapp dangkei/dockerapp 然后再执行就可以成功了 123456789101112E:\\code\\blog\\Blog&gt;docker push dangkei/dockerappUsing default tag: latestThe push refers to repository [docker.io/dangkei/dockerapp]e3db9e44151c: Layer already exists4d8245689bf1: Layer already exists202a657d4d12: Layer already exists4cd6f2e64dab: Layer already exists8ed905461d2d: Layer already exists853f8f81c1aa: Layer already exists0b7ff74144e3: Layer already exists9a5d14f9f550: Layer already existslatest: digest: sha256:fc741edbd1e41da5b04aa23e95ed924e09d07ae1bff2f2b1666c21de62d644df size: 2000","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (4) - build your image","slug":"how-to-use-docker-4","date":"2021-07-19T01:56:54.000Z","updated":"2021-07-21T03:07:30.302Z","comments":true,"path":"2021/07/19/how-to-use-docker-4/","link":"","permalink":"http://dangkei.github.io/2021/07/19/how-to-use-docker-4/","excerpt":"","text":"how to create docker image 之前的教程都是在学习如何使用已有的docker镜像创建容器，今天我们学习一下，使用docker创建自己的镜像容器。我们可以把已经开发好的应用，添加到已有的镜像文件，打包为自己的镜像文件方便使用，到快速安装部署的目的。首先我们可以从这里下载需要用来测试打包的应用down load Zip这是一个待办事项的nodejs应用程序，你不必了解nodejs。这只是作为一个例子. 利用 Dockerfile 来创建镜像 * 使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享。我们可以使用 docker build 来创建一个新的镜像。为此，首先解压缩app.zip后 copy app文件夹到 E:\\code目录下。然后重命名为dockerapp并且在这个文件夹中创建一个名为Dockerfile的文件，这个文件中包含一些如何创建镜像的指令。 12E:\\code&gt;ren app dockerappE:\\code&gt;cd dockerapp 1. 在dockerapp中创建一个文件Dockerfile是一个没有后缀名的文件,名称就是dockerfile的文本文件， 文件中每一条指令都创建镜像的一层，例如： 12345678# This is a comment FROM node:12-alpine MAINTAINER Docker dangkei &lt;dangkei@163.com&gt;RUN apk add --no-cache python g++ makeWORKDIR /appCOPY . .RUN yarn install --productionCMD [&quot;node&quot;, &quot;src/index.js&quot;] 2. 保存完毕后，dockerfile当前所在的目录使用docker build命令创建镜像1E:\\code\\dockerapp&gt;docker build -t dockerapp . 执行后可以看到运行结果 12345678910111213[+] Building 34.4s (11/11) FINISHED =&gt; [internal] load build definition from Dockerfile 0.1s =&gt; =&gt; transferring dockerfile: 251B 0.0s =&gt; [internal] load .dockerignore 0.1s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [internal] load metadata for docker.io/library/node:12-alpine 5.9s =&gt; [auth] library/node:pull token for registry-1.docker.io . . . =&gt; =&gt; exporting layers 1.2s =&gt; =&gt; writing image sha256:c8f742b494bcee74a08ac4dc93ce9b2824a68e09d693977d3969bdddd82c1095 0.0s =&gt; =&gt; naming to docker.io/library/dockerapp 0.0s 此命令使用 Dockerfile 构建新的容器镜像。您可能已经注意到下载了很多“层”。 因为我们指示构建器我们要从使用node:12-alpine镜像开始。但是，由于我们的机器上没有该镜像，因此需要下载该镜像。 下载镜像后，我们复制到我们的应用程序中并用yarn安装我们应用程序的依赖项。该CMD指令指定从该映像启动容器时要运行的默认命令。 最后，-t标志标记我们的镜像。将此简单地视为最终镜像的人类可读名称。由于我们将镜像命名为dockerapp，因此我们可以在运行容器时引用该镜像。 最后一个. 表示当前目录是为了告诉docker build命令Dockerfile文件所在的位置。 3. 现在运行docker images可以看到我们自己新创建的镜像了123E:\\code\\dockerapp&gt;docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdockerapp latest c8f742b494bc 22 minutes ago 294MB 4. 使用自己创建的镜像创建容器12E:\\code\\dockerapp&gt;docker run -dp 3000:3000 dockerappb6704592a1a6cff48fb30de95bb76af63b376ab855f3ae1dc25b289c7437697e 打开浏览器访问 http://localhost:3000端口测试一下结果 学习愉快！","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (3) Pull an Image from Docker Repository","slug":"how-to-use-docker-3","date":"2021-07-14T03:05:07.000Z","updated":"2021-07-23T08:52:09.390Z","comments":true,"path":"2021/07/14/how-to-use-docker-3/","link":"","permalink":"http://dangkei.github.io/2021/07/14/how-to-use-docker-3/","excerpt":"","text":"根据昨天经验，今天再把本地的mysql数据库环境转移到docker 1. pull image 第一步还是要拉镜像版本选择和原环境相同的版本 1docker pull mysql:5.7.25 2. run image 还是先直接把命令行脚本发出了，我们在一步步详细解说， 1docker run -dp 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=password -v D:\\docker\\mysql3306\\conf:/etc/mysql/conf.d -v D:\\docker\\mysql3306\\data:/var/lib/mysql mysql:5.7.25 类似相同的功能不说了，看看启动mysql容器时和之前redis有什么不同和需要注意的。 设置root密码-e MYSQL_ROOT_PASSWORD=123456 对于/etc/mysql/conf.d这个目录最新官方MySQL(5.7.19)的docker镜像在创建时映射的配置文件目录有所不同，在此记录并分享给大家： 官方原文： The MySQL startup configuration is specified in the file /etc/mysql/my.cnf, and that file in turn includes any files found in the /etc/mysql/conf.d directory that end with .cnf. Settings in files in this directory will augment and/or override settings in /etc/mysql/my.cnf. If you want to use a customized MySQL configuration, you can create your alternative configuration file in a directory on the host machine and then mount that directory location as /etc/mysql/conf.d inside the mysql container. 大概意思是说： MySQL(5.7.19)的默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。 通过这条规则，我们可以把有的镜像启动的配置文件挂载到/etc/appname/conf.d这里就可以让镜像中应用使用我们自定义配置启动 这样下来是不是很方便， 不管镜像中默认配置如何只要把自定义配置挂载到指定目录就可以了。 -v D:\\docker\\mysql3306\\data:/var/lib/mysql 宿主机的D:\\docker\\mysql3306\\data 目录挂载到容器/var/lib/mysql的Mysql数据存储目录下。 测试一下，使用mysql客户端连接数据库后新建一个名称为test的空数据库， 可以看到在宿主机的D:\\docker\\mysql3306\\data文件夹下生成了对应的test文件夹说明配置生效了。 配置linux下mysql时用到的一些命令 查找mysqldwhereis mysql 查找生效的mysql配置文件/usr/sbin/mysqld --verbose --help |grep -A 1 &#39;Default options&#39;执行后结果1234root@0f303c0363dc:/# /usr/sbin/mysqld --verbose --help |grep -A 1 &#x27;Default options&#x27;mysqld: [Warning] World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored.Default options are read from the following files in the given order:/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf mysqld: [Warning] World-writable config file ‘/etc/mysql/conf.d/my.cnf’ is ignored.查了些资料这句要说明意思是/etc/mysql/conf.d/my.cnf 是一个所有人可以读写的文件，为了安全起见忽略这个文件的配置。注意！ 这时候你的配置文件是不起作用的，容器还是按默认配置启动的mysql数据库处理的这个问题的办法是,进入容器执行下面的命令 1chmod 644 /etc/mysql/conf.d/my.cnf 然后再重启容器配置文件就可以生效了。 查看mysql对应版本的所有配置项1docker run -it --rm mysql:tag --verbose --help &gt; help.txt 然后打开当前目录下的help.txt查看","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (2) Mount host File or Floder","slug":"how-to-use-docker-2","date":"2021-07-13T06:33:59.000Z","updated":"2021-07-21T03:24:44.510Z","comments":true,"path":"2021/07/13/how-to-use-docker-2/","link":"","permalink":"http://dangkei.github.io/2021/07/13/how-to-use-docker-2/","excerpt":"","text":"挂载文件及目录 在个人开发电脑上装了docker以后就想把自己平时的本地开发环境全部转成docker管理方式首先想转换的就是redis数据库,我们平时用的redis设置密码 外加持久化存储。默认的镜像肯定不能满足开发环境需求。查了一些资料过程不说了最后整理下面的命令。 1docker run -p 6379:6379 --name redis6379 -v D:\\Database\\redis3.0.5\\redis_6379.conf:/etc/redis/redis.conf -v D:\\Database\\data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes 拆解说明一下 6379：6379 第一个6379 是本地发布映射端口 第二个6379是镜像中默认端口 --name redis6379 给容器起一个名字方便以后使用 -v D:\\Database\\redis3.0.5\\redis_6379.conf:/etc/redis/redis.conf -v D:\\Database\\data:/data 参数-v的作用是挂载本地系统文件或文件夹,这里使用了两次， 第一个-v挂载本地redis_6379.conf到镜像容器中命名为redis.conf 第二个-v挂载本地的D:\\Database\\data目录为容器中的/data目录 -d redis -d redis 是后台使用redis镜像启动 redis-server /etc/redis/redis.conf启动后使用挂载的配置文件来启动redis --appendonly yesredis配置选项持久化存储设置生效 这样命令执行完之后我就可以使用docker管理开发环境的redis服务器启动。而不是需要在本地命令行或者通过配置windows服务的方式启动redis。而各种设置和数据的存储和在本地安装程序一样。 可以想象一下，如果将来我们更换电脑或者开发环境。 只需保存好配置文件，和数据存储文件。就可以快速部署或者一个和之前一样的开发环境。 通过-v这个参数的挂载功能将应用参数数据完全与数据库或者中间件分离，方便快速管理部署。","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"how to use docker (1) Setup Docker-Desktop and Run a Container","slug":"how-to-use-docker-1","date":"2021-07-12T09:31:31.000Z","updated":"2021-07-21T09:13:35.522Z","comments":true,"path":"2021/07/12/how-to-use-docker-1/","link":"","permalink":"http://dangkei.github.io/2021/07/12/how-to-use-docker-1/","excerpt":"","text":"1. download for windows https://hub.docker.com/ 安装步骤省略 按提示一步步安装即可 2. find a image 我们可以在网站上找一些官方的镜像[Official Images]例如 我搜索一下nginx 在结果中 我选择类型为Official Images的直接拿来可以使用 也可以在命令行执行 1docker search nginx 点击进入后页面右侧会有提示该如何在本地下载该镜像 直接拷贝命令后到本地命令行执行 123456789101112E:\\code\\&gt;docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxb4d181a07f80: Already exists66b1c490df3f: Pull completed0f91ae9b44c: Pull completebaf987068537: Pull complete6bbc76cbebeb: Pull complete32b766478bc2: Pull completeDigest: sha256:353c20f74d9b6aee359f30e8e4f69c3d7eaea2f610681c4a95849a2fd7c497f9Status: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest 然后打开 docker-desktop 可以看到本地已经有nginx的镜像可以直接使用了。 3. use the image点击run就直接在本地运行一个redis的docker容器。或者使用命令行 1docker run --name mynginx -d nginx:latest docker run 参数很多。 有机会需要的时候可以慢慢研究。这里就不做详细介绍了。 4. 一些简单的docker命令行命令 查看本地有哪些镜像 1docker images 查看本地运行的docker 容器 1docker ps 进入容器内命令行 1docker exec -i -t 容器ID /bin/bash 修改容器配置常用命令 12apt-get updateapt-get install -y vim 一般官方容器装的软件很少，我们要修改一些基本配置至少要安装下vi 复制宿主机中文件到docker容器中 1docker cp D:\\Database\\redis3.0.5\\redis_6379.conf db0794db0d16:/etc/redis/redis.conf 反之拷贝容器中文件到宿主机 1docker cp db0794db0d16:/etc/redis/redis.conf D:\\Database\\redis3.0.5\\redis_6379.conf 两条命令都是在宿主机中执行 查看已经创建的容器 1docker ps -a 启动已经创建的容器 1docker start con_name/id 删除指定名称或者id的容器 1docker rm con_name/id 删除指定名称的镜像 1docker rmi img_name 更改容器的名称 1docker rename old_con_name new_con_name 查看容器日志 1docker logs -f redis6379(容器id) 查看容器网络 1docker network create netname(网络名称) 简单介绍这些菜鸟教程里比较全有需要可以去那边查，祝大家学习愉快！https://www.runoob.com/docker/docker-command-manual.html","categories":[{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"}]},{"title":"Java 8特色Lambda 表达式","slug":"lambda-expressions","date":"2021-07-09T02:58:38.000Z","updated":"2021-07-09T02:47:39.238Z","comments":true,"path":"2021/07/09/lambda-expressions/","link":"","permalink":"http://dangkei.github.io/2021/07/09/lambda-expressions/","excerpt":"","text":"Java 8 – Lambda 表达式 Lambda 表达式是Java 8 的一个非常新的和令人兴奋的特性。Lambda 样式表达式对于我们中许多从事过像 Scala 这样的高级语言工作的人来说并不陌生。 在本 Java 教程中，我们将了解 lambda 表达式及其相关的各种概念。 什么是 Lambda 表达式？ Lambda 表达式语法 Java 8 Lambda 表达式的特点 Java 8 功能接口 Java 8 Lambda 表达式示例 让我们按部就班，一步一步来。 1. 什么是 Lambda 表达式？ 在一般编程语言中，Lambda 表达式（或函数）是匿名函数，即没有名称和任何标识符的函数。 Lambda 表达式是作为常量值给出的无名函数，并准确地写在需要它的地方，通常作为其他函数的参数。 Lambda 表达式最重要的特性是它们在其外观的上下文中执行。因此，类似的 lambda 表达式可以在其他一些上下文中以不同的方式执行（即逻辑将相同但结果将根据传递给函数的不同参数而不同）。 上面的定义充满了关键字，只有当你对什么是 lambda 表达式有一点了解时才能理解。因此，一旦您在下一节中对 lambda 表达式有了更好的理解，我建议您重新阅读上一段。 与面向对象编程(OOP) 相比，Lambda 表达式为函数式编程提供了许多好处。大多数 OOP 语言围绕类和对象发展，这些语言只将类视为它们的一等公民。另一个重要的实体，即职能部门，处于次要地位。 在 Java 中尤其如此，其中函数不能存在于对象之外。函数本身在 Java 中没有任何意义，除非它与某个对象或实例相关。 但是在函数式编程中，我们可以定义函数，给它们提供引用变量，并将它们作为方法参数传递等等。 JavaScript 是函数式编程的一个很好的例子，我们可以将回调方法传递给Ajax调用等等。这是一个非常有用的特性，从一开始就缺乏Java。现在有了 Java 8，我们还可以在 lambda 表达式的帮助下使用函数式编程概念。 2. Lambda 表达式语法典型的 lambda 表达式语法如下所示： 1(parameters) -&gt; expression 例如，给定的 lambda 表达式接受两个参数并返回它们的相加。 根据xand的类型y，表达式的使用方式会有所不同。如果参数与Integer表达式匹配，则将两个数字相加。如果参数类型String为表达式，则将连接两个字符串。 1(x, y) -&gt; x + y 3. Java 8 Lambda 表达式的特点一个 lambda 表达式可以有零个、一个或多个参数。参数的类型可以显式声明，也可以从上下文中推断出来。多个参数用强制括号括起来并用逗号分隔。空括号用于表示一组空参数。 1() -&gt; expression (param1, param2, param3) -&gt; expression 当有单个参数时，如果推断其类型，则不强制使用括号。例如 a -&gt; 返回 a*a。lambda 表达式的主体可以包含零个、一个或多个语句。如果 lambda 表达式的主体有单个语句，则大括号不是必需的，并且匿名函数的返回类型与主体表达式的返回类型相同。当正文中有多个语句时，必须将这些语句括在大括号中。(parameters) -&gt; &#123; statements; &#125;因此，我们简要概述了什么是 lambda 表达式。在深入研究 lambda 表达式和 Java 编程之间的关系之前，我们还必须了解函数式接口。这太重要了。 4. Java 8 功能接口单一抽象方法接口（SAM Interfaces）并不是一个新概念。这意味着只有一种方法的接口。在 Java 中，我们已经有很多此类 SAM 接口的示例。 从 Java 8 开始，SAM 接口也将被称为功能接口。Java 8通过使用新的注释（即@FunctionalInterface ）标记这些接口来强制执行单一职责的规则。 例如，Runnable 接口的新定义是这样的： 1234@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 如果我们尝试在任何函数式接口中添加新方法，编译器将不允许您这样做，并且会抛出编译时错误。 我们知道 Lambda 表达式是没有名称的匿名函数，它们（主要）作为参数传递给其他函数。好吧，在 Java 中，方法参数总是有一个类型，并且会查找类型信息以确定在方法重载甚至简单方法调用的情况下需要调用哪个方法。 因此，基本上每个 lambda 表达式也必须可以转换为某种“类型”才能被接受为方法参数。好吧，转换 lambda 表达式的类型始终是函数式接口类型。 函数式接口类型的两个很好的例子是Consumer和BiConsumer接口。 让我们通过一个例子来理解它。如果我们必须编写一个线程来在控制台中打印“hello word!”，那么最简单的代码将是： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;hello word!&quot;); &#125;&#125;).start(); 如果我们为此任务使用 lambda 表达式，则代码将是： 123new Thread(() -&gt; &#123; System.out.println(&quot;hello word! First!&quot;); &#125;).run(); 这Runnable是一个具有单一方法的功能接口run()。因此，当我们将 lambda 表达式传递给Thread类的构造函数时，编译器会尝试将表达式转换为等效Runnable代码，如第一个代码示例所示。 如果编译器成功，则一切正常。如果编译器无法将表达式转换为等效的实现代码，它就会报错。在这里，在上面的示例中，lambda 表达式被转换为 type Runnable。 lambda 表达式是函数式接口的一个实例，但 lambda 表达式本身不包含有关它正在实现的函数式接口的信息。该信息是从使用表达式的上下文中推导出来的。 5. Java 8 Lambda 表达式示例 我们列出了一些代码示例，您可以阅读并分析如何在我们的日常编程中使用 lambda 表达式。 示例 1：使用 lambda 表达式迭代 List 并对列表元素执行某些操作 在给定的示例中，我们迭代列表并打印标准输出中的所有列表元素。我们可以执行任何所需的操作来代替打印它们。 1234567List&lt;String&gt; pointList = new ArrayList(); pointList.add(&quot;1&quot;);pointList.add(&quot;2&quot;); pointList.forEach(p -&gt; &#123; System.out.println(p); &#125; ); 示例 2：在 Java 中使用 lambda 表达式创建和启动线程在给定的示例中，我们将Runnable接口的实例传递给Thread构造函数。 123new Thread( () -&gt; System.out.println(&quot;My Runnable&quot;); ).start(); 示例 3：使用 lambda 表达式向 GUI 组件添加事件侦听器JButton button = new JButton(&quot;Submit&quot;); button.addActionListener((e) -&gt; &#123; System.out.println(&quot;Click event triggered !!&quot;); &#125;); 以上是 Java 8 中非常基本的 lambda 表达式示例。","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://dangkei.github.io/tags/lambda/"}]},{"title":"nodejs里写一个自定义的redis客户端","slug":"nodejs-redisclient","date":"2021-07-08T07:23:53.000Z","updated":"2021-07-30T03:37:30.427Z","comments":true,"path":"2021/07/08/nodejs-redisclient/","link":"","permalink":"http://dangkei.github.io/2021/07/08/nodejs-redisclient/","excerpt":"","text":"一. 什么是Node.js?Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。 Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 官网上对其特点描述为： 它是一个Javascript运行环境 依赖于Chrome V8引擎进行代码解释 事件驱动 非阻塞I/O 轻量、可伸缩，适于实时数据交互应用 单进程，单线程 二. Node.js中模块化开发规范Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到。模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块。 三. 自己写一个操作redis的client 模块。 首先我们需要安装nodejs环境 首先我们要在nodejs中使用redis必须下载redis模块，在你的项目文件夹下执行下面命令1npm install redis 1. 准备配置文件按习惯，我们先在项目文件夹下建一个文件夹modules再在这个文件夹下建一个文件夹redis我希望把redis链接的相关信息写在一个配置文件而不是程序内，所以我首先创建一个redis的配置文件文件名为config.jsonconfig.json 12345678&#123; &quot;redis&quot;:&#123; &quot;port&quot;:&quot;6379&quot;, &quot;host&quot;:&quot;localhost&quot;, &quot;password&quot;:&quot;password&quot;, &quot;detect_buffers&quot;: &quot;true&quot; &#125;&#125; 2. 引入相关模块 开始写redisClient.js,首先把redis插件和自定义的配置文件声明进来 12const redis = require(&#x27;redis&#x27;)const redisOptions = require(&#x27;./config&#x27;).redis 3. 从redisOptions文件中读取并配置redis options参数信息 然后设置redis配置信息，出了连接方式还有缓存设置以及重连机制 1234567891011121314151617181920212223242526const options = &#123; host: redisOptions.host, port: redisOptions.port, password: redisOptions.pass, detect_buffers: redisOptions.detect_buffers, // 传入buffer 返回也是buffer 否则会转换成String retry_strategy: function (options) &#123; // 重连机制 if (options.error &amp;&amp; options.error.code === &quot;ECONNREFUSED&quot;) &#123; // End reconnecting on a specific error and flush all commands with // a individual error return new Error(&quot;The server refused the connection&quot;); &#125; if (options.total_retry_time &gt; 1000 * 60 * 60) &#123; // End reconnecting after a specific timeout and flush all commands // with a individual error return new Error(&quot;Retry time exhausted&quot;); &#125; if (options.attempt &gt; 10) &#123; // End reconnecting with built in error return undefined; &#125; // reconnect after return Math.min(options.attempt * 100, 3000); &#125;&#125; 4. 定义模块方法 接下来我们根据设置好的参数创建一个redis客户端对象&gt; 并且定义4个需要暴露在模块外使用的方法 setValue //存储值 getValue //读取String getHvalue //读取hash quit //退出 12345678// 生成redis的clientconst client = redis.createClient(options)const setValue = ()=&gt;&#123;&#125;const getValue = ()=&gt;&#123;&#125;const getHValue = ()=&gt;&#123;&#125;const quit = ()=&gt;&#123;&#125; 完善方法 1234567891011121314151617181920212223242526272829303132333435363738394041 // 存储值const setValue = (key, value) =&gt; &#123; if (typeof value === &#x27;string&#x27;) &#123; client.set(key, value) &#125; else if (typeof value === &#x27;object&#x27;) &#123; for (let item in value) &#123; client.hmset(key, item, value[item],redis.print) &#125; &#125;&#125; // 获取stringconst getValue = (key) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; client.get(key, (err, res) =&gt; &#123; if (err) &#123; reject(err) &#125;else&#123; resolve(res) &#125; &#125;) &#125;)&#125; // 获取hashconst getHValue = (key) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; client.hgetall(key, function (err, value) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(value) &#125; &#125;) &#125;)&#125; const quit = () =&gt; &#123; client.quit();&#125; 5. 暴露出可以调用的方法 使用module.exports 将外部可调用方法暴露出来。 1234567// 导出module.exports = &#123; setValue, getValue, getHValue, quit&#125; 四. 写个文件测试一下testRedis.js 1234567891011121314151617181920212223const redis = require(&#x27;./modules/redis/redisClient&#x27;) redis.setValue(&#x27;student&#x27;, &#123; name: &#x27;xiaoming&#x27;, age: 18, sex: 1&#125;) redis.setValue(&#x27;book&#x27;, &#x27;yuwen&#x27;) redis.getValue(&#x27;book&#x27;).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; throw new Error(err)&#125;) redis.getHValue(&#x27;student&#x27;).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; throw new Error(err)&#125;)redis.quit(); output: 123456D:\\workspace\\redisClient&gt;node testRedis.jsReply: OKReply: OKReply: OKyuwen&#123; name: &#x27;xiaoming&#x27;, age: &#x27;18&#x27;, sex: &#x27;1&#x27; &#125; 成功了！！","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://dangkei.github.io/tags/redis/"},{"name":"nodejs","slug":"nodejs","permalink":"http://dangkei.github.io/tags/nodejs/"}]},{"title":"Java大括号初始化对象","slug":"Java-double-brace-initialization","date":"2021-07-06T10:30:00.000Z","updated":"2021-07-08T01:19:12.522Z","comments":true,"path":"2021/07/06/Java-double-brace-initialization/","link":"","permalink":"http://dangkei.github.io/2021/07/06/Java-double-brace-initialization/","excerpt":"","text":"Java Double Brace Initialization 1. 创建和初始化不带双大括号的对象您不觉得Java应该为集合（List、Map、Set等）提供更方便的语法吗。我之所以这么说，是因为每次如果我们必须在代码中使用集合，那么我们就必须执行以下操作- 为临时集合声明变量 创建一个新的空集合，并在变量中存储对它的引用 把东西收藏起来 将集合传递给方法 例如：WithoutDoubleBrace.java 123456789101112131415161718192021import java.util.HashSet;import java.util.Set; public class WithoutDoubleBrace &#123; public static void main(String[] args) &#123; Set&lt;String&gt; params = new HashSet&lt;String&gt;(); params.add(&quot;param one&quot;); params.add(&quot;param two&quot;); params.add(&quot;param three&quot;); params.add(&quot;param four&quot;); // ... and so on; Now pass above collection as parameter to method or // some other ways useParamsInSomeMethod(params); &#125; private static void useParamsInSomeMethod(Set&lt;String&gt; params) &#123; // TODO Auto-generated method stub &#125;&#125; 这些都是我们在实时编码实践中遵循的正常步骤。 2. 在“单步”中创建和初始化对象的双大括号初始化让我们看看另一种简单的方法。这就是所谓的双大括号初始化。使用双大括号功能的语法如下： DoubleBrace.java 12345678910111213141516171819202122232425import java.util.HashSet;import java.util.Set; public class DoubleBrace &#123; public static void main(String[] args) &#123; Set&lt;String&gt; params = new HashSet&lt;String&gt;() &#123; &#123; add(&quot;param one&quot;); add(&quot;param two&quot;); add(&quot;param three&quot;); add(&quot;param four&quot;); &#125; &#125;; // ... and so on; Now pass above collection as parameter to method or // some other ways useParamsInSomeMethod(params); &#125; private static void useParamsInSomeMethod(Set&lt;String&gt; params) &#123; // TODO Auto-generated method stub &#125;&#125; 2.1. 内联双大括号初始化或者更简单一些： 12345678910111213141516171819import java.util.HashSet; public class DoubleBrace &#123; public static void main(String[] args) &#123; useParamsInSomeMethod(new HashSet&lt;String&gt;() &#123; &#123; add(&quot;param one&quot;); add(&quot;param two&quot;); add(&quot;param three&quot;); add(&quot;param four&quot;); &#125; &#125;); &#125; private static void useParamsInSomeMethod(HashSet&lt;String&gt; params) &#123; //perform some operation &#125;&#125; 3. 双大括号初始化如何工作？让我们了解这是如何工作的。 第一个大括号创建一个新的匿名内部类。这些内部类能够访问其父类的行为。所以，在我们的例子中，我们实际上是在创建HashSet类的子类，所以这个内部类能够使用add（）方法。 第二组大括号只不过是初始化实例。如果您提醒核心java概念，那么您可以很容易地将实例初始值设定项块与静态初始值设定项相关联，因为类似于大括号的结构。唯一的区别是，静态初始值设定项是用static关键字添加的，并且只运行一次；不管您创建了多少个对象。 4. 总结 因为用双括号初始化的类基本上是内部类。所以我们可以为所有其他类创建它们，直到它们不是最终的。 如果没有显式修改equals（）方法以使用这些类，则不应使用此类类，因为equals（）方法通常也会检查类的相等性。 您应该始终记住，初始值设定项是在构造函数之前运行的（而不是在超类构造函数之前）。 您创建的匿名类的实例包含对封闭对象的合成引用。如果序列化集合，还将序列化外部类中的所有内容。 5. Java 9 工厂方法Java 9带来了很多工厂方法，可以用来创建和初始化单个语句中的Java集合。如果您使用Java 9或更高版本，它可以是一种替代方法，也是首选方法。它消除了双支撑初始化的必要性。 12345678List&lt;String&gt; names = List.of(&quot;lokesh&quot;, &quot;rohit&quot;, &quot;alex&quot;); Set&lt;String&gt; names = Set.of(&quot;Lokesh&quot;, &quot;Amit&quot;, &quot;John&quot;); Map&lt;String, String&gt; names = Map.ofEntries( Map.entry(&quot;1&quot;, &quot;Lokesh&quot;), Map.entry(&quot;2&quot;, &quot;Amit&quot;), Map.entry(&quot;3&quot;, &quot;Brian&quot;)); 6. Java 8 流收集器对于Java 8和更低版本，您可以在Java流的形式中找到类似的用例。 12Set&lt;String&gt; names = Stream.of(&quot;lokesh&quot;, &quot;rohit&quot;, &quot;alex&quot;) .collect( collectingAndThen( toSet(), Collections::unmodifiableSet ) );","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"Initialization","slug":"Initialization","permalink":"http://dangkei.github.io/tags/Initialization/"}]},{"title":"Java的标准IO与新IO有什么区别","slug":"java-standard-IO-vs-new-IO","date":"2021-07-05T07:42:37.000Z","updated":"2021-07-07T06:43:24.050Z","comments":true,"path":"2021/07/05/java-standard-IO-vs-new-IO/","link":"","permalink":"http://dangkei.github.io/2021/07/05/java-standard-IO-vs-new-IO/","excerpt":"","text":"Java Standard IO vs New IO Java 新输入/输出 (NIO)是随 JDK 1.4 引入的。从标准 IO 的角度出发，NIO 为 Java 库提供了高速、面向块的 IO。 通过定义类来保存数据，并通过在块中处理该数据，NIO 以一种java.io包无法使用的方式利用低级优化，而不使用本机代码。 在本文中，我们将重点确定标准 IO 与新 IO 之间最显着的差异，在决定在下一个项目中使用哪个之前，我们必须了解这些差异。 调用标准 IOJava IO是指计算机与世界其他部分之间或单个程序与计算机其他部分之间的接口。 在 Java 编程中，IO 类直到最近才使用流比喻来实现。所有 IO 都被视为单个字节的移动，一次一个，通过名为 a 的对象Stream。 Stream IO 用于联系外界。它也在内部使用，用于将对象转换为字节，然后再转换为对象。它被称为序列化和反序列化。 介绍 Java 新 IOJava NIO 的创建是为了让 Java 程序员无需编写自定义本机代码即可实现高速输入-输出操作。 NIO 将最耗时的 I/O 活动（即填充和排空缓冲区）移回操作系统，从而大大提高速度。 如果以上介绍让您感到口渴，请不要担心，随着我们的前进，您是否会感觉更好。让我们从找出差异开始。 IO 和 NIO 的区别IO 流与 NIO 块标准 IO 库 ( java.io.) 和新 IO ( java.nio.)之间最重要的区别在于数据如何打包并从源传输到目标。如前所述，标准 I/O 处理流中的数据，而 NIO 处理块中的数据。 甲面向流的I / O与数据系统处理的一个或多个字节一次。输入流产生一字节数据，输出流消耗一字节数据。为流数据创建过滤器非常容易。将几个过滤器链接在一起也相对简单，这样每个过滤器都可以在一个复杂的处理机制中发挥作用。 重要的是字节不会缓存在任何地方。此外，我们不能在流中的数据中来回移动。如果您需要在从流中读取的数据中来回移动，我们必须首先将其缓存在缓冲区中。 甲面向块的I / O系统涉及在块中的数据。每个操作在一个步骤中产生或消耗一个数据块。按块处理数据比按（流）字节处理数据快得多。您可以根据需要在缓冲区中前后移动。 数据块在处理过程中为我们提供了更多的灵活性。但是，我们还需要检查缓冲区是否包含我们需要的所有数据，以便完全处理它。并且，我们需要确保在将更多数据读入缓冲区时，我们不会覆盖尚未处理的缓冲区中的数据。 不利的一面是，面向块的 I/O 缺乏面向流 I/O 的一些优雅和简单。 阅读更多：使用 Java NIO 读取文件的 3 种方法 同步标准与异步新 IOJava IO 的各种流都是阻塞的或同步的。这意味着，当一个线程调用read()orwrite()操作时，该线程被阻塞，直到有一些数据要读取，或者数据被完全写入。该线程将在此期间处于阻塞状态。这被认为是在现代语言中引入多线程的一个很好的充分理由。 在异步 IO 中，线程可以请求将某些数据写入通道，但不会等待它完全写入。然后该线程可以继续并同时执行其他操作。通常这些线程在没有被 IO 调用阻塞的时候将它们的空闲时间花在同时在其他通道上执行 IO 上。也就是说，单个线程现在可以管理多个输入和输出通道。 同步程序通常不得不求助于轮询，或者创建很多很多线程来处理大量连接。使用异步 I/O，您可以在任意数量的通道上监听 I/O 事件，无需轮询和额外线程。 异步 I/O 中的中心对象称为Selector。Selector 是您注册对各种 IO 事件感兴趣的地方，它是告诉您这些事件何时发生的对象。所以，我们需要做的第一件事就是创建一个 Selector。 Selector selector = Selector.open();稍后，我们将register()在各种Channel对象上调用该方法，以注册我们对这些对象内部发生的 IO 事件的兴趣。的第一个参数register()始终是Selector。 阅读更多：如何在 Java NIO 中定义路径 Java IO 与 NIO API不用猜测使用 NIO 时的 API 调用看起来与使用 IO 时的不同。在 NIO 中，不是仅仅从例如 an 中读取一个字节的数据字节，而是InputStream必须首先将数据读入 a Buffer，然后从其后进行处理。 使用标准 IO 读取文件的 Java 示例。 123456789101112131415161718192021222324252627282930313233343536&gt;import java.io.BufferedReader;&gt;import java.io.FileReader;&gt;import java.io.IOException;&gt;public class WithoutNIOExample&gt;&#123; public static void main(String[] args) &#123; BufferedReader br = null; String sCurrentLine = null; try &#123; br = new BufferedReader( new FileReader(&quot;test.txt&quot;)); while ((sCurrentLine = br.readLine()) != null) &#123; System.out.println(sCurrentLine); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (br != null) br.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;&gt;&#125; 使用 New IO 读取文件的 Java 示例。 1234567891011121314151617181920212223242526&gt;import java.io.IOException;&gt;import java.io.RandomAccessFile;&gt;import java.nio.ByteBuffer;&gt;import java.nio.channels.FileChannel;&gt;public class ReadFileWithFixedSizeBuffer&gt;&#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile aFile = new RandomAccessFile (&quot;test.txt&quot;, &quot;r&quot;); FileChannel inChannel = aFile.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while(inChannel.read(buffer) &gt; 0) &#123; buffer.flip(); for (int i = 0; i &lt; buffer.limit(); i++) &#123; System.out.print((char) buffer.get()); &#125; buffer.clear(); // do something with the data and clear/compact it. &#125; inChannel.close(); aFile.close(); &#125;&gt;&#125; 结论NIO 允许您仅使用单个（或更少）线程来管理多个通道，但代价是解析数据可能比使用标准 IO 从阻塞流中读取数据要复杂一些。 如果您需要同时管理数千个打开的连接，每个连接只发送少量数据，例如聊天服务器，在 NIO 中实现服务器可能是一个优势。同样，如果您需要与其他计算机保持大量开放连接，例如在 P2P 网络中，使用单个线程来管理所有出站连接可能是一个优势。 如果您的连接较少且带宽非常高，一次发送大量数据，则应该选择标准 IO 服务器实现。 本文翻译自：https://howtodoinjava.com/java/io/difference-between-io-nio/","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"}]},{"title":"Java IO内部是如何工作的?","slug":"how-java-io-work","date":"2021-07-01T08:17:34.000Z","updated":"2021-07-06T07:27:12.478Z","comments":true,"path":"2021/07/01/how-java-io-work/","link":"","permalink":"http://dangkei.github.io/2021/07/01/how-java-io-work/","excerpt":"","text":"本文旨在为那些好奇知道如何在机器级别映射Java IO操作以及在应用程序运行时硬件始终做什么的读者编写。 我假设您熟悉基本的IO操作，例如读取文件、通过JavaIO API编写文件；因为这超出了本文的范围。 缓冲区处理和内核与用户空间“input/output”一词只意味着将数据移出缓冲区。 缓冲区以及缓冲区的处理方式是所有IO的基础。你只要时刻记住这个。 通常，进程通过请求操作系统从缓冲区（写入操作）中排出数据或用数据填充缓冲区（读取操作）来执行IO。这是IO概念的全部总结。 操作系统中执行这些传输的机器可能非常复杂，但从概念上讲，它非常简单，我们将在本文中讨论其中的一小部分。 os级的数据缓冲 上图显示了块数据如何从外部源（例如硬盘）移动到正在运行的进程（例如RAM）内的内存区域的简化“逻辑”图。 首先，进程请求通过调用read（）系统来填充其缓冲区。 读调用导致内核向磁盘控制器硬件发出命令，以从磁盘中获取数据。 磁盘控制器通过DMA直接将数据写入内核内存缓冲区，而不需要主CPU的进一步帮助。 磁盘控制器完成缓冲区填充后，内核将数据从内核空间中的临时缓冲区复制到进程指定的缓冲区；当请求read（）操作时。 需要注意的一点是内核试图缓存和/或预取数据，因此进程请求的数据可能已经在内核空间中可用。如果是，则将复制流程请求的数据。 如果数据不可用，则进程将暂停，而内核则将数据带入内存。 虚拟内存 您一定已经多次听说过虚拟内存。让我想想。 所有现代操作系统都利用虚拟内存。虚拟内存是指人工地址或虚拟地址被用来代替物理（硬件RAM）内存地址。 虚拟内存带来两个重要优势： 多个虚拟地址可以引用相同的物理内存位置。 虚拟内存空间可以大于实际可用硬件内存。 在前面的部分中，从内核空间复制到最终用户缓冲区似乎是额外的工作。为什么不告诉磁盘控制器直接发送到userspace中的缓冲区？好吧，它是用虚拟内存完成的，这是上面的优势1。 通过将内核空间地址映射到与用户空间中的虚拟地址相同的物理地址，DMA硬件（只能访问物理内存地址）可以填充内核和用户空间进程同时可见的缓冲区。 这消除了内核和用户空间之间的拷贝，但需要内核和用户缓冲区共享相同的页面对齐方式。缓冲区还必须是磁盘控制器使用的块大小的倍数（通常是512字节磁盘扇区）。 操作系统将内存地址空间划分为页，页是固定大小的字节组。这些内存页总是磁盘块大小的倍数，通常是2的幂（这简化了寻址）。典型的内存页大小是1024、2048和4096字节。 虚拟内存页和物理内存页的大小总是相同的。 内存分页 为了支持虚拟内存的第二个优点（可寻址空间大于物理内存），有必要进行虚拟内存分页（通常称为交换）。 内存分页是一种方案，通过这种方案，虚拟内存空间的页面可以持久化到外部磁盘存储器中，以便在物理内存中为其他虚拟页面腾出空间。从本质上讲，物理内存充当分页区域的缓存，分页区域是磁盘上的空间，当物理内存被挤出时，存储内存页的内容。 将内存页大小调整为磁盘块大小的倍数允许内核向磁盘控制器硬件发出直接命令，将内存页写入磁盘或在需要时重新加载它们。 原来，所有磁盘IO都是在页面级别完成的。在现代的分页操作系统中，这是数据在磁盘和物理内存之间移动的唯一方式。 现代CPU包含一个子系统，称为内存管理单元（MMU）。这个设备在逻辑上位于CPU和物理内存之间。MMU包含将虚拟地址转换为物理内存地址所需的映射信息。 当CPU引用内存位置时，MMU确定该位置所在的页（通常通过移动或屏蔽地址值的位）并将该虚拟页号转换为物理页号（这在硬件中完成，并且非常快）。 面向文件/块的IO 文件IO总是发生在文件系统的上下文中。文件系统与磁盘截然不同。磁盘将数据存储在扇区中，每个扇区通常为512字节。它们是对文件的语义一无所知的硬件设备。它们只是提供了一些可以存储数据的插槽。在这方面，磁盘的扇区类似于内存页；所有扇区的大小都是一致的，并且可以作为一个大数组寻址。 另一方面，文件系统是更高层次的抽象。文件系统是一种特殊的方法，用于排列和解释存储在磁盘（或其他一些随机存取、面向块的设备）上的数据。您编写的代码几乎总是与文件系统交互，而不是直接与磁盘交互。文件系统定义了文件名、路径、文件、文件属性等的抽象。 文件系统（在硬盘中）组织一系列大小一致的数据块。一些块存储元信息，如空闲块、目录、索引等的映射。其他块包含实际的文件数据。 有关单个文件的元信息描述了哪些块包含文件数据、数据结束的位置、上次更新的时间等。 当用户进程请求读取文件数据时，文件系统实现会准确地确定数据在磁盘上的位置。然后它采取措施将这些磁盘扇区放入内存。 文件系统也有页的概念，页的大小可以是基本内存页的大小，也可以是基本内存页的倍数。典型的文件系统页面大小从2048字节到8192字节不等，并且总是基本内存页面大小的倍数。 分页文件系统如何执行IO归结为以下逻辑步骤： 确定请求跨越的文件系统页（磁盘扇区组）。磁盘上的文件内容和/或元数据可能分布在多个文件系统页面上，这些页面可能是不连续的。 在内核空间中分配足够的内存页以容纳已标识的文件系统页。 在这些内存页和磁盘上的文件系统页之间建立映射。 为每个内存页生成页错误。 虚拟内存系统捕获页面错误并调度pagein（即分页空间pagein），通过从磁盘读取页面内容来验证这些页面。 一旦pagein完成，文件系统就会分解原始数据以提取请求的文件内容或属性信息。 注意，这个文件系统数据将像其他内存页一样被缓存。在随后的IO请求中，部分或全部文件数据可能仍存在于物理内存中，并且可以重用，而无需从磁盘重新读取 文件锁定 文件锁定是一种方案，通过该方案，一个进程可以阻止其他进程访问某个文件或限制其他进程访问该文件的方式。虽然“文件锁定”这个名称意味着锁定整个文件（通常是这样做的），但锁定通常在更细粒度的级别上可用。 文件区域通常是锁定的，粒度降低到字节级别。锁与特定文件相关联，从该文件中的特定字节位置开始，并在特定的字节范围内运行。这一点很重要，因为它允许许多进程协调对文件特定区域的访问，而不会妨碍文件中其他进程的工作。 文件锁有两种类型：共享锁和独占锁。多个共享锁可能同时对同一文件区域有效。另一方面，独占锁要求没有其他锁对请求的区域有效。 流IO 并非所有IO都是面向块的。还有流IO，它是基于管道建模的。必须按顺序访问IO流的字节。TTY（控制台）设备、打印机端口和网络连接是流的常见示例。 流通常（但不一定）比块设备慢，并且通常是间歇输入的源。大多数操作系统允许将流置于非阻塞模式，这允许进程检查流上的输入是否可用，如果此时没有可用的输入，则不会卡住。这样的功能允许进程在输入到达时处理输入，但在输入流空闲时执行其他功能。 超越非阻塞模式的一个步骤是能够进行就绪选择。这类似于非阻塞模式（并且通常构建在非阻塞模式之上），但是减轻了对流是否准备好用于操作系统的检查。 可以告诉操作系统监视流的集合，并向进程返回指示哪些流已就绪。这种能力允许进程利用操作系统返回的就绪信息，使用公共代码和单个线程多路复用多个活动流。 流IO在网络服务器中被广泛用于处理大量的网络连接。准备就绪选择对于高容量扩展至关重要。 这些都是关于这个有大量技术词汇的非常复杂的话题🙂","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"}]},{"title":"静态导入声明的一些重要规则","slug":"import-rules","date":"2021-07-01T07:59:18.000Z","updated":"2021-07-06T08:08:07.770Z","comments":true,"path":"2021/07/01/import-rules/","link":"","permalink":"http://dangkei.github.io/2021/07/01/import-rules/","excerpt":"","text":"import static静态导入是JDK1.5中的新特性。一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.;这里的多了个static，还有就是类名ClassName后面多了个 . ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便 下面是关于静态导入声明的一些重要规则。 1） 如果导入两个具有相同简单名称的静态成员，一个使用单个静态导入声明，另一个使用静态按需导入声明，则使用单个静态导入声明导入的静态成员优先。 假设有两个类，package1.Class1和package2.Class2。两个类都有一个名为methodA的静态方法。以下代码将使用package1.Class1.methodA（）方法，因为它是使用单个静态导入声明导入的： 12345678&gt;import static package1.Class1.methodA; // Imports Class1.methodA() method&gt;import static package2.Class2.*; // Imports Class2.methodA() method too &gt;public class Test &#123; public static void main(String[] args) &#123; methodA(); // Class1.methodA() will be called &#125;&gt;&#125; 2） 不允许使用单个静态导入声明导入两个具有相同简单名称的静态成员。以下静态导入声明生成错误，因为它们都使用相同的简单名称methodA导入静态成员： 12&gt;import static package1.Class1.methodA;&gt;import static package1.Class2.methodA; // An error 3） 如果使用单个静态导入声明导入静态成员，并且同一类中存在同名的静态成员，则该类中的静态成员将被使用。 123456789101112131415161718192021222324252627&gt;// A.java&gt;package package1; &gt;public class A &#123; public static void test() &#123; System.out.println(&quot;package1.A.test()&quot;); &#125;&gt;&#125; &gt;// Test.java&gt;package package2; &gt;import static package1.A.test; &gt;public class Test &#123; public static void main(String[] args) &#123; test(); // Will use package2.Test.test() method, not package1.A.test() method &#125; public static void test() &#123; System.out.println(&quot;package2.Test.test()&quot;); &#125;&gt;&#125;&gt;Output:&gt;package2.Test.test() 静态导入似乎可以帮助您使用静态成员的简单名称，从而使程序更易于编写和读取。有时静态导入可能会在程序中引入细微的错误，这可能很难调试。建议您完全不要使用静态导入，或者仅在非常罕见的情况下使用。","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"static","slug":"static","permalink":"http://dangkei.github.io/tags/static/"},{"name":"import","slug":"import","permalink":"http://dangkei.github.io/tags/import/"}]},{"title":"common knowledge of java","slug":"java-basic-concepts","date":"2020-07-26T06:34:45.000Z","updated":"2021-07-30T09:06:12.805Z","comments":true,"path":"2020/07/26/java-basic-concepts/","link":"","permalink":"http://dangkei.github.io/2020/07/26/java-basic-concepts/","excerpt":"","text":"1. java语言中 函数参数是基本数据类型时传参是值传递的， 参数是对象时参数也是值传递只不过时的是传递对象的引用。2. java基本数据类型- byte 1个字节 取值 -128(10000000,-2^7)——+127(01111111,2^7-1) - short 2个字节 取值 -32768(-2^15)————32767(2^15-1) - int 4个自己 取值 -2,147,483,648(-2^31)————2,147.483,647(2^31-1) - long 8个字节 取值 -9,223,372,036,854,775,808(-2^63)————0,223,372,036,854,775,807(2^63-1) 3. 溢出示例123456int i = Integer.MAX_VALUE;int j = Integer.MAX_VALUE;int k = i + j;System.out.println(&quot;k=&quot;+k);output:k=-2 3. 浮点数不能来表示金额，应该使用BigDecimal或者Long(单位为分)来表示金额。4. transient 关键字修饰的对象或成员变量在序列化时会被忽略，反序列化时设为初始值。5. instanceof 关键字时一个二元操作符类似‘==’，‘&gt;’。6. synchronized 特性 synchronized既可以修饰方法也可以修饰代码块+ 可见性 + 有序性 + 原子性 synchronized的原子性指的是一个操作不可能中断，必须完全执行完毕， 否则就不执行。 7. volatile 特性 volatile 关键字是一个轻量级的synchronized,只能修饰变量 不能修饰方法和代码块。 当java内存模型中多级缓存写操作volatile修饰的变量时jvm会lock这个变量并且将这个变量回写到主缓存中。+ 可见性 + 有序性 + 不具原子性 8. String的所有方法都不改变原有值只是返回一个新对象9. 其他字符串类+ StringBuffer //线程安全 + StringBuilder //线程不安全 + apache.commons.StringUtil //拼接数组 循环体内推荐使用StringBuffer或者 StringBuilder拼接 使用+每次都会new一个新String 资源浪费！ 10. 字符串拼接效率 StringBuild&gt;StringBuffer&gt;concat&gt;StringUtil.join11. 常量池- Class常量池 - 字符串常量池 - 运行时常量池 12. 字符串常量池存放位置- JDK1.7以前 : 存在永久代 - JDK1.7 : 存放在堆内存中， - JDK1.7以后 : 再次移动到永久代 13. Class常量池可以看作Class文件的资源仓库 查看Class文件中常量池的方法： 1javap -v helloword.class 14. 常量池中存放的常量分两大类- 字面量(Literal) - 符号引用(symbolic references) 15. 字面量 - 是由字母，数字等构成的数值。指的是等号右边的值。- 字母 - 数字 16. 符号引用- 类和接口的权限定名 //eg: public class xxx - 字段的名称和描述符 //eg: public String name - 方法的名称和描述符 //eg: public void add() 17. 运行时常量- 运行时常量分配在JVM的方法区 - JDK1.7之前 存在于永久代 - JDK1.7 存在于 堆内存 - JDK1.7后 存在于元空间 JVM虚拟机启动时把class文件载入到运行时常量池就是内存中， 如果class常量池中包含字符串会被装载到字符串常量池 18. intern作用： 返回字符串常量池中该字符串引用，如果字符串常量池没油该字符串就创建并返回它的引用","categories":[{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"}],"tags":[{"name":"concepts","slug":"concepts","permalink":"http://dangkei.github.io/tags/concepts/"}]},{"title":"Hello hexo on github","slug":"hello-hexo","date":"2020-01-01T09:31:31.000Z","updated":"2021-07-30T02:24:27.447Z","comments":true,"path":"2020/01/01/hello-hexo/","link":"","permalink":"http://dangkei.github.io/2020/01/01/hello-hexo/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server123$ hexo server //or$ hexo s More info: Server Generate static files123$ hexo generate//or$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy//or$ hexo d More info: Deployment config local git123git config –global user.name yournamegit config –global user.email youremail generated your login secrtkey1Ssh-keygen -t rsa -C yourname@mail.com","categories":[{"name":"hexo","slug":"hexo","permalink":"http://dangkei.github.io/categories/hexo/"}],"tags":[]},{"title":"spring 3 不完全兼容 JDK8问题","slug":"bug-mark-001","date":"2019-07-28T07:26:31.000Z","updated":"2021-07-29T06:48:44.807Z","comments":true,"path":"2019/07/28/bug-mark-001/","link":"","permalink":"http://dangkei.github.io/2019/07/28/bug-mark-001/","excerpt":"","text":"今天一个修改一个项目优化后启动报错如下 1234567891011121314151617181920Caused by: java.lang.ArrayIndexOutOfBoundsException: 27233 at org.springframework.asm.ClassReader.readClass(Unknown Source) at org.springframework.asm.ClassReader.accept(Unknown Source) at org.springframework.asm.ClassReader.accept(Unknown Source) at org.springframework.core.type.classreading.SimpleMetadataReader.getAnnotationMetadata(SimpleMetadataReader.java:55) at org.springframework.core.type.filter.AnnotationTypeFilter.matchSelf(AnnotationTypeFilter.java:68) at org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter.match(AbstractTypeHierarchyTraversingFilter.java:55) at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.isCandidateComponent(ClassPathScanningCandidateComponentProvider.java:252) at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:192) at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:201) at org.springframework.context.annotation.ComponentScanBeanDefinitionParser.parse(ComponentScanBeanDefinitionParser.java:84) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:69) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1297) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1287) at org.apache.xbean.spring.context.v2.XBeanBeanDefinitionDocumentReader.parseBeanDefinitions(XBeanBeanDefinitionDocumentReader.java:84) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:92) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:507) at org.apache.xbean.spring.context.v2.XBeanXmlBeanDefinitionReader.registerBeanDefinitions(XBeanXmlBeanDefinitionReader.java:79) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:398) ... 35 more 乍一看以为是数组下标越界，但是仔细看是spring容器读取bean错误。 最后网上查了一下资料原来项目JDK版本是1.8，spring的版本是3，spring 3不完全兼容JDK8， 这次的修改自己使用了lambda表达式造成了被修改过的bean不能被spring容器识别。","categories":[{"name":"bug marked","slug":"bug-marked","permalink":"http://dangkei.github.io/categories/bug-marked/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://dangkei.github.io/tags/lambda/"},{"name":"spring3","slug":"spring3","permalink":"http://dangkei.github.io/tags/spring3/"},{"name":"JDK8","slug":"JDK8","permalink":"http://dangkei.github.io/tags/JDK8/"}]}],"categories":[{"name":"coding","slug":"coding","permalink":"http://dangkei.github.io/categories/coding/"},{"name":"devopts","slug":"devopts","permalink":"http://dangkei.github.io/categories/devopts/"},{"name":"java","slug":"java","permalink":"http://dangkei.github.io/categories/java/"},{"name":"hexo","slug":"hexo","permalink":"http://dangkei.github.io/categories/hexo/"},{"name":"bug marked","slug":"bug-marked","permalink":"http://dangkei.github.io/categories/bug-marked/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://dangkei.github.io/tags/javascript/"},{"name":"docker","slug":"docker","permalink":"http://dangkei.github.io/tags/docker/"},{"name":"lambda","slug":"lambda","permalink":"http://dangkei.github.io/tags/lambda/"},{"name":"redis","slug":"redis","permalink":"http://dangkei.github.io/tags/redis/"},{"name":"nodejs","slug":"nodejs","permalink":"http://dangkei.github.io/tags/nodejs/"},{"name":"Initialization","slug":"Initialization","permalink":"http://dangkei.github.io/tags/Initialization/"},{"name":"IO","slug":"IO","permalink":"http://dangkei.github.io/tags/IO/"},{"name":"static","slug":"static","permalink":"http://dangkei.github.io/tags/static/"},{"name":"import","slug":"import","permalink":"http://dangkei.github.io/tags/import/"},{"name":"concepts","slug":"concepts","permalink":"http://dangkei.github.io/tags/concepts/"},{"name":"spring3","slug":"spring3","permalink":"http://dangkei.github.io/tags/spring3/"},{"name":"JDK8","slug":"JDK8","permalink":"http://dangkei.github.io/tags/JDK8/"}]}